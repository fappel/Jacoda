import { BaseFileSystem } from '../core/file_system';
import { ApiError, ErrorCode } from '../core/api_error';
import { ActionType } from '../core/file_flag';
import { copyingSlice, deprecationMessage } from '../core/util';
import { NoSyncFile } from '../generic/preload_file';
import { asyncDownloadFile, syncDownloadFile, getFileSizeAsync, getFileSizeSync } from '../generic/xhr';
import { FileIndex, isFileInode, isDirInode } from '../generic/file_index';
/**
 * Try to convert the given buffer into a string, and pass it to the callback.
 * Optimization that removes the needed try/catch into a helper function, as
 * this is an uncommon case.
 * @hidden
 */
function tryToString(buff, encoding, cb) {
    try {
        cb(null, buff.toString(encoding));
    }
    catch (e) {
        cb(e);
    }
}
/**
 * A simple filesystem backed by XMLHttpRequests. You must create a directory listing using the
 * `make_xhrfs_index` tool provided by BrowserFS.
 *
 * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by
 * running `make_xhrfs_index` in your terminal in the directory you would like to index:
 *
 * ```
 * make_xhrfs_index > index.json
 * ```
 *
 * Listings objects look like the following:
 *
 * ```json
 * {
 *   "home": {
 *     "jvilk": {
 *       "someFile.txt": null,
 *       "someDir": {
 *         // Empty directory
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*
 */
export default class XmlHttpRequest extends BaseFileSystem {
    /**
     * **Deprecated. Please use XmlHttpRequest.Create() method instead to construct XmlHttpRequest objects.**
     *
     * Constructs the file system. You must provide the directory listing as a JSON object
     * produced by the `make_xhrfs_index` script.
     *
     * **DEPRECATED:** You may pass a URL to the file index to the constructor, which will fetch the file index
     * *synchronously* and may freeze up the web page. This behavior will be removed in the next major version
     * of BrowserFS.
     *
     * @param listingUrlOrObj index object or the path to the JSON file index generated by
     *   `make_xhrfs_index`.
     * @param prefixUrl URL that is prepended to any file locations in the file index. e.g. if `prefixUrl = 'data/`, and the user wants to open the file `/foo.txt`,
     * the file system will fetch file `data/foo.txt`. The browser will access the file relative to the currrent webpage
     * URL.
     */
    constructor(listingUrlOrObj, prefixUrl = '', deprecateMsg = true) {
        super();
        if (!listingUrlOrObj) {
            listingUrlOrObj = 'index.json';
        }
        // prefix_url must end in a directory separator.
        if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {
            prefixUrl = prefixUrl + '/';
        }
        this.prefixUrl = prefixUrl;
        let listing = null;
        if (typeof (listingUrlOrObj) === "string") {
            listing = this._requestFileSync(listingUrlOrObj, 'json');
            if (!listing) {
                throw new Error("Unable to find listing at URL: ${listingUrlOrObj}");
            }
        }
        else {
            listing = listingUrlOrObj;
        }
        deprecationMessage(deprecateMsg, XmlHttpRequest.Name, { index: typeof (listingUrlOrObj) === "string" ? listingUrlOrObj : "file index as an object", baseUrl: prefixUrl });
        this._index = FileIndex.fromListing(listing);
    }
    /**
     * Construct an XmlHttpRequest file system backend with the given options.
     */
    static Create(opts, cb) {
        if (opts.index === undefined) {
            opts.index = `index.json`;
        }
        if (typeof (opts.index) === "string") {
            XmlHttpRequest.FromURL(opts.index, cb, opts.baseUrl, false);
        }
        else {
            cb(null, new XmlHttpRequest(opts.index, opts.baseUrl, false));
        }
    }
    static isAvailable() {
        return typeof (XMLHttpRequest) !== "undefined" && XMLHttpRequest !== null;
    }
    /**
     * **Deprecated. Please use XmlHttpRequest.Create() method instead to construct XmlHttpRequest objects.**
     *
     * Constructs an XmlHttpRequest object using the directory listing at the given URL.
     * Uses the base URL as the URL prefix for fetched files.
     * @param cb Called when the file system has been instantiated, or if an error occurs.
     */
    static FromURL(url, cb, baseUrl = url.slice(0, url.lastIndexOf('/') + 1), deprecateMsg = true) {
        if (deprecateMsg) {
            console.warn(`[XmlHttpRequest] XmlHttpRequest.FromURL() is deprecated and will be removed in the next major release. Please use 'XmlHttpRequest.Create({ index: "${url}", baseUrl: "${baseUrl}" }, cb)' instead.`);
        }
        asyncDownloadFile(url, "json", (e, data) => {
            if (e) {
                cb(e);
            }
            else {
                cb(null, new XmlHttpRequest(data, baseUrl, false));
            }
        });
    }
    empty() {
        this._index.fileIterator(function (file) {
            file.fileData = null;
        });
    }
    getName() {
        return XmlHttpRequest.Name;
    }
    diskSpace(path, cb) {
        // Read-only file system. We could calculate the total space, but that's not
        // important right now.
        cb(0, 0);
    }
    isReadOnly() {
        return true;
    }
    supportsLinks() {
        return false;
    }
    supportsProps() {
        return false;
    }
    supportsSynch() {
        return true;
    }
    /**
     * Special XHR function: Preload the given file into the index.
     * @param [String] path
     * @param [BrowserFS.Buffer] buffer
     */
    preloadFile(path, buffer) {
        const inode = this._index.getInode(path);
        if (isFileInode(inode)) {
            if (inode === null) {
                throw ApiError.ENOENT(path);
            }
            const stats = inode.getData();
            stats.size = buffer.length;
            stats.fileData = buffer;
        }
        else {
            throw ApiError.EISDIR(path);
        }
    }
    stat(path, isLstat, cb) {
        const inode = this._index.getInode(path);
        if (inode === null) {
            return cb(ApiError.ENOENT(path));
        }
        let stats;
        if (isFileInode(inode)) {
            stats = inode.getData();
            // At this point, a non-opened file will still have default stats from the listing.
            if (stats.size < 0) {
                this._requestFileSizeAsync(path, function (e, size) {
                    if (e) {
                        return cb(e);
                    }
                    stats.size = size;
                    cb(null, stats.clone());
                });
            }
            else {
                cb(null, stats.clone());
            }
        }
        else if (isDirInode(inode)) {
            stats = inode.getStats();
            cb(null, stats);
        }
        else {
            cb(ApiError.FileError(ErrorCode.EINVAL, path));
        }
    }
    statSync(path, isLstat) {
        const inode = this._index.getInode(path);
        if (inode === null) {
            throw ApiError.ENOENT(path);
        }
        let stats;
        if (isFileInode(inode)) {
            stats = inode.getData();
            // At this point, a non-opened file will still have default stats from the listing.
            if (stats.size < 0) {
                stats.size = this._requestFileSizeSync(path);
            }
        }
        else if (isDirInode(inode)) {
            stats = inode.getStats();
        }
        else {
            throw ApiError.FileError(ErrorCode.EINVAL, path);
        }
        return stats;
    }
    open(path, flags, mode, cb) {
        // INVARIANT: You can't write to files on this file system.
        if (flags.isWriteable()) {
            return cb(new ApiError(ErrorCode.EPERM, path));
        }
        const self = this;
        // Check if the path exists, and is a file.
        const inode = this._index.getInode(path);
        if (inode === null) {
            return cb(ApiError.ENOENT(path));
        }
        if (isFileInode(inode)) {
            const stats = inode.getData();
            switch (flags.pathExistsAction()) {
                case ActionType.THROW_EXCEPTION:
                case ActionType.TRUNCATE_FILE:
                    return cb(ApiError.EEXIST(path));
                case ActionType.NOP:
                    // Use existing file contents.
                    // XXX: Uh, this maintains the previously-used flag.
                    if (stats.fileData) {
                        return cb(null, new NoSyncFile(self, path, flags, stats.clone(), stats.fileData));
                    }
                    // @todo be lazier about actually requesting the file
                    this._requestFileAsync(path, 'buffer', function (err, buffer) {
                        if (err) {
                            return cb(err);
                        }
                        // we don't initially have file sizes
                        stats.size = buffer.length;
                        stats.fileData = buffer;
                        return cb(null, new NoSyncFile(self, path, flags, stats.clone(), buffer));
                    });
                    break;
                default:
                    return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.'));
            }
        }
        else {
            return cb(ApiError.EISDIR(path));
        }
    }
    openSync(path, flags, mode) {
        // INVARIANT: You can't write to files on this file system.
        if (flags.isWriteable()) {
            throw new ApiError(ErrorCode.EPERM, path);
        }
        // Check if the path exists, and is a file.
        const inode = this._index.getInode(path);
        if (inode === null) {
            throw ApiError.ENOENT(path);
        }
        if (isFileInode(inode)) {
            const stats = inode.getData();
            switch (flags.pathExistsAction()) {
                case ActionType.THROW_EXCEPTION:
                case ActionType.TRUNCATE_FILE:
                    throw ApiError.EEXIST(path);
                case ActionType.NOP:
                    // Use existing file contents.
                    // XXX: Uh, this maintains the previously-used flag.
                    if (stats.fileData) {
                        return new NoSyncFile(this, path, flags, stats.clone(), stats.fileData);
                    }
                    // @todo be lazier about actually requesting the file
                    const buffer = this._requestFileSync(path, 'buffer');
                    // we don't initially have file sizes
                    stats.size = buffer.length;
                    stats.fileData = buffer;
                    return new NoSyncFile(this, path, flags, stats.clone(), buffer);
                default:
                    throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');
            }
        }
        else {
            throw ApiError.EISDIR(path);
        }
    }
    readdir(path, cb) {
        try {
            cb(null, this.readdirSync(path));
        }
        catch (e) {
            cb(e);
        }
    }
    readdirSync(path) {
        // Check if it exists.
        const inode = this._index.getInode(path);
        if (inode === null) {
            throw ApiError.ENOENT(path);
        }
        else if (isDirInode(inode)) {
            return inode.getListing();
        }
        else {
            throw ApiError.ENOTDIR(path);
        }
    }
    /**
     * We have the entire file as a buffer; optimize readFile.
     */
    readFile(fname, encoding, flag, cb) {
        // Wrap cb in file closing code.
        const oldCb = cb;
        // Get file.
        this.open(fname, flag, 0x1a4, function (err, fd) {
            if (err) {
                return cb(err);
            }
            cb = function (err, arg) {
                fd.close(function (err2) {
                    if (!err) {
                        err = err2;
                    }
                    return oldCb(err, arg);
                });
            };
            const fdCast = fd;
            const fdBuff = fdCast.getBuffer();
            if (encoding === null) {
                cb(err, copyingSlice(fdBuff));
            }
            else {
                tryToString(fdBuff, encoding, cb);
            }
        });
    }
    /**
     * Specially-optimized readfile.
     */
    readFileSync(fname, encoding, flag) {
        // Get file.
        const fd = this.openSync(fname, flag, 0x1a4);
        try {
            const fdCast = fd;
            const fdBuff = fdCast.getBuffer();
            if (encoding === null) {
                return copyingSlice(fdBuff);
            }
            return fdBuff.toString(encoding);
        }
        finally {
            fd.closeSync();
        }
    }
    getXhrPath(filePath) {
        if (filePath.charAt(0) === '/') {
            filePath = filePath.slice(1);
        }
        return this.prefixUrl + filePath;
    }
    _requestFileAsync(p, type, cb) {
        asyncDownloadFile(this.getXhrPath(p), type, cb);
    }
    _requestFileSync(p, type) {
        return syncDownloadFile(this.getXhrPath(p), type);
    }
    /**
     * Only requests the HEAD content, for the file size.
     */
    _requestFileSizeAsync(path, cb) {
        getFileSizeAsync(this.getXhrPath(path), cb);
    }
    _requestFileSizeSync(path) {
        return getFileSizeSync(this.getXhrPath(path));
    }
}
XmlHttpRequest.Name = "XmlHttpRequest";
XmlHttpRequest.Options = {
    index: {
        type: ["string", "object"],
        optional: true,
        description: "URL to a file index as a JSON file or the file index object itself, generated with the make_xhrfs_index script. Defaults to `index.json`."
    },
    baseUrl: {
        type: "string",
        optional: true,
        description: "Used as the URL prefix for fetched files. Default: Fetch files relative to the index."
    }
};
//# sourceMappingURL=XmlHttpRequest.js.map