import PreloadFile from '../generic/preload_file';
import { BaseFileSystem } from '../core/file_system';
import { default as Stats, FileType } from '../core/node_fs_stats';
import { ApiError, ErrorCode } from '../core/api_error';
import { each as asyncEach } from 'async';
import * as path from 'path';
import { arrayBuffer2Buffer, buffer2ArrayBuffer, emptyBuffer, deprecationMessage } from '../core/util';
/**
 * @hidden
 */
let errorCodeLookup;
/**
 * Lazily construct error code lookup, since DropboxJS might be loaded *after* BrowserFS (or not at all!)
 * @hidden
 */
function constructErrorCodeLookup() {
    if (errorCodeLookup) {
        return;
    }
    errorCodeLookup = {};
    // This indicates a network transmission error on modern browsers. Internet Explorer might cause this code to be reported on some API server errors.
    errorCodeLookup[Dropbox.ApiError.NETWORK_ERROR] = ErrorCode.EIO;
    // This happens when the contentHash parameter passed to a Dropbox.Client#readdir or Dropbox.Client#stat matches the most recent content, so the API call response is omitted, to save bandwidth.
    // errorCodeLookup[Dropbox.ApiError.NO_CONTENT];
    // The error property on {Dropbox.ApiError#response} should indicate which input parameter is invalid and why.
    errorCodeLookup[Dropbox.ApiError.INVALID_PARAM] = ErrorCode.EINVAL;
    // The OAuth token used for the request will never become valid again, so the user should be re-authenticated.
    errorCodeLookup[Dropbox.ApiError.INVALID_TOKEN] = ErrorCode.EPERM;
    // This indicates a bug in dropbox.js and should never occur under normal circumstances.
    // ^ Actually, that's false. This occurs when you try to move folders to themselves, or move a file over another file.
    errorCodeLookup[Dropbox.ApiError.OAUTH_ERROR] = ErrorCode.EPERM;
    // This happens when trying to read from a non-existing file, readdir a non-existing directory, write a file into a non-existing directory, etc.
    errorCodeLookup[Dropbox.ApiError.NOT_FOUND] = ErrorCode.ENOENT;
    // This indicates a bug in dropbox.js and should never occur under normal circumstances.
    errorCodeLookup[Dropbox.ApiError.INVALID_METHOD] = ErrorCode.EINVAL;
    // This happens when a Dropbox.Client#readdir or Dropbox.Client#stat call would return more than a maximum amount of directory entries.
    errorCodeLookup[Dropbox.ApiError.NOT_ACCEPTABLE] = ErrorCode.EINVAL;
    // This is used by some backend methods to indicate that the client needs to download server-side changes and perform conflict resolution. Under normal usage, errors with this code should never surface to the code using dropbox.js.
    errorCodeLookup[Dropbox.ApiError.CONFLICT] = ErrorCode.EINVAL;
    // Status value indicating that the application is making too many requests.
    errorCodeLookup[Dropbox.ApiError.RATE_LIMITED] = ErrorCode.EBUSY;
    // The request should be retried after some time.
    errorCodeLookup[Dropbox.ApiError.SERVER_ERROR] = ErrorCode.EBUSY;
    // Status value indicating that the user's Dropbox is over its storage quota.
    errorCodeLookup[Dropbox.ApiError.OVER_QUOTA] = ErrorCode.ENOSPC;
}
/**
 * @hidden
 */
function isFileInfo(cache) {
    return cache && cache.stat.isFile;
}
/**
 * @hidden
 */
function isDirInfo(cache) {
    return cache && cache.stat.isFolder;
}
/**
 * @hidden
 */
function isArrayBuffer(ab) {
    // Accept null / undefined, too.
    return ab === null || ab === undefined || (typeof (ab) === 'object' && typeof (ab['byteLength']) === 'number');
}
/**
 * Wraps a Dropbox client and caches operations.
 * @hidden
 */
class CachedDropboxClient {
    constructor(client) {
        this._cache = {};
        this._client = client;
    }
    readdir(p, cb) {
        const cacheInfo = this.getCachedDirInfo(p);
        this._wrap((interceptCb) => {
            if (cacheInfo !== null && cacheInfo.contents) {
                this._client.readdir(p, {
                    contentHash: cacheInfo.stat.contentHash
                }, interceptCb);
            }
            else {
                this._client.readdir(p, interceptCb);
            }
        }, (err, filenames, stat, folderEntries) => {
            if (err) {
                if (err.status === Dropbox.ApiError.NO_CONTENT && cacheInfo !== null) {
                    cb(null, cacheInfo.contents.slice(0));
                }
                else {
                    cb(err);
                }
            }
            else {
                this.updateCachedDirInfo(p, stat, filenames.slice(0));
                folderEntries.forEach((entry) => {
                    this.updateCachedInfo(path.join(p, entry.name), entry);
                });
                cb(null, filenames);
            }
        });
    }
    remove(p, cb) {
        this._wrap((interceptCb) => {
            this._client.remove(p, interceptCb);
        }, (err, stat) => {
            if (!err) {
                this.updateCachedInfo(p, stat);
            }
            cb(err);
        });
    }
    move(src, dest, cb) {
        this._wrap((interceptCb) => {
            this._client.move(src, dest, interceptCb);
        }, (err, stat) => {
            if (!err) {
                this.deleteCachedInfo(src);
                this.updateCachedInfo(dest, stat);
            }
            cb(err);
        });
    }
    stat(p, cb) {
        this._wrap((interceptCb) => {
            this._client.stat(p, interceptCb);
        }, (err, stat) => {
            if (!err) {
                this.updateCachedInfo(p, stat);
            }
            cb(err, stat);
        });
    }
    readFile(p, cb) {
        const cacheInfo = this.getCachedFileInfo(p);
        if (cacheInfo !== null && cacheInfo.contents !== null) {
            // Try to use cached info; issue a stat to see if contents are up-to-date.
            this.stat(p, (error, stat) => {
                if (error) {
                    cb(error);
                }
                else if (stat.contentHash === cacheInfo.stat.contentHash) {
                    // No file changes.
                    cb(error, cacheInfo.contents.slice(0), cacheInfo.stat);
                }
                else {
                    // File changes; rerun to trigger actual readFile.
                    this.readFile(p, cb);
                }
            });
        }
        else {
            this._wrap((interceptCb) => {
                this._client.readFile(p, { arrayBuffer: true }, interceptCb);
            }, (err, contents, stat) => {
                if (!err) {
                    this.updateCachedInfo(p, stat, contents.slice(0));
                }
                cb(err, contents, stat);
            });
        }
    }
    writeFile(p, contents, cb) {
        this._wrap((interceptCb) => {
            this._client.writeFile(p, contents, interceptCb);
        }, (err, stat) => {
            if (!err) {
                this.updateCachedInfo(p, stat, contents.slice(0));
            }
            cb(err, stat);
        });
    }
    mkdir(p, cb) {
        this._wrap((interceptCb) => {
            this._client.mkdir(p, interceptCb);
        }, (err, stat) => {
            if (!err) {
                this.updateCachedInfo(p, stat, []);
            }
            cb(err);
        });
    }
    /**
     * Wraps an operation such that we retry a failed operation 3 times.
     * Necessary to deal with Dropbox rate limiting.
     *
     * @param performOp Function that performs the operation. Will be called up to three times.
     * @param cb Called when the operation succeeds, fails in a non-temporary manner, or fails three times.
     */
    _wrap(performOp, cb) {
        let numRun = 0;
        const interceptCb = function (error) {
            // Timeout duration, in seconds.
            const timeoutDuration = 2;
            if (error && 3 > (++numRun)) {
                switch (error.status) {
                    case Dropbox.ApiError.SERVER_ERROR:
                    case Dropbox.ApiError.NETWORK_ERROR:
                    case Dropbox.ApiError.RATE_LIMITED:
                        setTimeout(() => {
                            performOp(interceptCb);
                        }, timeoutDuration * 1000);
                        break;
                    default:
                        cb.apply(null, arguments);
                        break;
                }
            }
            else {
                cb.apply(null, arguments);
            }
        };
        performOp(interceptCb);
    }
    getCachedInfo(p) {
        return this._cache[p.toLowerCase()];
    }
    putCachedInfo(p, cache) {
        this._cache[p.toLowerCase()] = cache;
    }
    deleteCachedInfo(p) {
        delete this._cache[p.toLowerCase()];
    }
    getCachedDirInfo(p) {
        const info = this.getCachedInfo(p);
        if (isDirInfo(info)) {
            return info;
        }
        else {
            return null;
        }
    }
    getCachedFileInfo(p) {
        const info = this.getCachedInfo(p);
        if (isFileInfo(info)) {
            return info;
        }
        else {
            return null;
        }
    }
    updateCachedDirInfo(p, stat, contents = null) {
        const cachedInfo = this.getCachedInfo(p);
        // Dropbox uses the *contentHash* property for directories.
        // Ignore stat objects w/o a contentHash defined; those actually exist!!!
        // (Example: readdir returns an array of stat objs; stat objs for dirs in that context have no contentHash)
        if (stat.contentHash !== null && (cachedInfo === undefined || cachedInfo.stat.contentHash !== stat.contentHash)) {
            this.putCachedInfo(p, {
                stat: stat,
                contents: contents
            });
        }
    }
    updateCachedFileInfo(p, stat, contents = null) {
        const cachedInfo = this.getCachedInfo(p);
        // Dropbox uses the *versionTag* property for files.
        // Ignore stat objects w/o a versionTag defined.
        if (stat.versionTag !== null && (cachedInfo === undefined || cachedInfo.stat.versionTag !== stat.versionTag)) {
            this.putCachedInfo(p, {
                stat: stat,
                contents: contents
            });
        }
    }
    updateCachedInfo(p, stat, contents = null) {
        if (stat.isFile && isArrayBuffer(contents)) {
            this.updateCachedFileInfo(p, stat, contents);
        }
        else if (stat.isFolder && Array.isArray(contents)) {
            this.updateCachedDirInfo(p, stat, contents);
        }
    }
}
export class DropboxFile extends PreloadFile {
    constructor(_fs, _path, _flag, _stat, contents) {
        super(_fs, _path, _flag, _stat, contents);
    }
    sync(cb) {
        if (this.isDirty()) {
            const buffer = this.getBuffer(), arrayBuffer = buffer2ArrayBuffer(buffer);
            this._fs._writeFileStrict(this.getPath(), arrayBuffer, (e) => {
                if (!e) {
                    this.resetDirty();
                }
                cb(e);
            });
        }
        else {
            cb();
        }
    }
    close(cb) {
        this.sync(cb);
    }
}
/**
 * A read/write file system backed by Dropbox cloud storage.
 *
 * Uses the Dropbox V1 API.
 *
 * NOTE: You must use the v0.10 version of the [Dropbox JavaScript SDK](https://www.npmjs.com/package/dropbox).
 */
export default class DropboxFileSystem extends BaseFileSystem {
    /**
     * **Deprecated. Please use Dropbox.Create() method instead.**
     *
     * Constructs a Dropbox-backed file system using the *authenticated* DropboxJS client.
     *
     * Note that you must use the old v0.10 version of the Dropbox JavaScript SDK.
     */
    constructor(client, deprecateMsg = true) {
        super();
        this._client = new CachedDropboxClient(client);
        deprecationMessage(deprecateMsg, DropboxFileSystem.Name, { client: "authenticated dropbox client instance" });
        constructErrorCodeLookup();
    }
    /**
     * Creates a new DropboxFileSystem instance with the given options.
     * Must be given an *authenticated* DropboxJS client from the old v0.10 version of the Dropbox JS SDK.
     */
    static Create(opts, cb) {
        cb(null, new DropboxFileSystem(opts.client, false));
    }
    static isAvailable() {
        // Checks if the Dropbox library is loaded.
        return typeof Dropbox !== 'undefined';
    }
    getName() {
        return DropboxFileSystem.Name;
    }
    isReadOnly() {
        return false;
    }
    // Dropbox doesn't support symlinks, properties, or synchronous calls
    supportsSymlinks() {
        return false;
    }
    supportsProps() {
        return false;
    }
    supportsSynch() {
        return false;
    }
    empty(mainCb) {
        this._client.readdir('/', (error, files) => {
            if (error) {
                mainCb(this.convert(error, '/'));
            }
            else {
                const deleteFile = (file, cb) => {
                    const p = path.join('/', file);
                    this._client.remove(p, (err) => {
                        cb(err ? this.convert(err, p) : null);
                    });
                };
                const finished = (err) => {
                    if (err) {
                        mainCb(err);
                    }
                    else {
                        mainCb();
                    }
                };
                // XXX: <any> typing is to get around overly-restrictive ErrorCallback typing.
                asyncEach(files, deleteFile, finished);
            }
        });
    }
    rename(oldPath, newPath, cb) {
        this._client.move(oldPath, newPath, (error) => {
            if (error) {
                // the move is permitted if newPath is a file.
                // Check if this is the case, and remove if so.
                this._client.stat(newPath, (error2, stat) => {
                    if (error2 || stat.isFolder) {
                        const missingPath = error.response.error.indexOf(oldPath) > -1 ? oldPath : newPath;
                        cb(this.convert(error, missingPath));
                    }
                    else {
                        // Delete file, repeat rename.
                        this._client.remove(newPath, (error2) => {
                            if (error2) {
                                cb(this.convert(error2, newPath));
                            }
                            else {
                                this.rename(oldPath, newPath, cb);
                            }
                        });
                    }
                });
            }
            else {
                cb();
            }
        });
    }
    stat(path, isLstat, cb) {
        // Ignore lstat case -- Dropbox doesn't support symlinks
        // Stat the file
        this._client.stat(path, (error, stat) => {
            if (error) {
                cb(this.convert(error, path));
            }
            else if (stat && stat.isRemoved) {
                // Dropbox keeps track of deleted files, so if a file has existed in the
                // past but doesn't any longer, you wont get an error
                cb(ApiError.FileError(ErrorCode.ENOENT, path));
            }
            else {
                const stats = new Stats(this._statType(stat), stat.size);
                return cb(null, stats);
            }
        });
    }
    open(path, flags, mode, cb) {
        // Try and get the file's contents
        this._client.readFile(path, (error, content, dbStat) => {
            if (error) {
                // If the file's being opened for reading and doesn't exist, return an
                // error
                if (flags.isReadable()) {
                    cb(this.convert(error, path));
                }
                else {
                    switch (error.status) {
                        // If it's being opened for writing or appending, create it so that
                        // it can be written to
                        case Dropbox.ApiError.NOT_FOUND:
                            const ab = new ArrayBuffer(0);
                            return this._writeFileStrict(path, ab, (error2, stat) => {
                                if (error2) {
                                    cb(error2);
                                }
                                else {
                                    const file = this._makeFile(path, flags, stat, arrayBuffer2Buffer(ab));
                                    cb(null, file);
                                }
                            });
                        default:
                            return cb(this.convert(error, path));
                    }
                }
            }
            else {
                // No error
                let buffer;
                // Dropbox.js seems to set `content` to `null` rather than to an empty
                // buffer when reading an empty file. Not sure why this is.
                if (content === null) {
                    buffer = emptyBuffer();
                }
                else {
                    buffer = arrayBuffer2Buffer(content);
                }
                const file = this._makeFile(path, flags, dbStat, buffer);
                return cb(null, file);
            }
        });
    }
    _writeFileStrict(p, data, cb) {
        const parent = path.dirname(p);
        this.stat(parent, false, (error, stat) => {
            if (error) {
                cb(ApiError.FileError(ErrorCode.ENOENT, parent));
            }
            else {
                this._client.writeFile(p, data, (error2, stat) => {
                    if (error2) {
                        cb(this.convert(error2, p));
                    }
                    else {
                        cb(null, stat);
                    }
                });
            }
        });
    }
    /**
     * Private
     * Returns a BrowserFS object representing the type of a Dropbox.js stat object
     */
    _statType(stat) {
        return stat.isFile ? FileType.FILE : FileType.DIRECTORY;
    }
    /**
     * Private
     * Returns a BrowserFS object representing a File, created from the data
     * returned by calls to the Dropbox API.
     */
    _makeFile(path, flag, stat, buffer) {
        const type = this._statType(stat);
        const stats = new Stats(type, stat.size);
        return new DropboxFile(this, path, flag, stats, buffer);
    }
    /**
     * Private
     * Delete a file or directory from Dropbox
     * isFile should reflect which call was made to remove the it (`unlink` or
     * `rmdir`). If this doesn't match what's actually at `path`, an error will be
     * returned
     */
    _remove(path, cb, isFile) {
        this._client.stat(path, (error, stat) => {
            if (error) {
                cb(this.convert(error, path));
            }
            else {
                if (stat.isFile && !isFile) {
                    cb(ApiError.FileError(ErrorCode.ENOTDIR, path));
                }
                else if (!stat.isFile && isFile) {
                    cb(ApiError.FileError(ErrorCode.EISDIR, path));
                }
                else {
                    this._client.remove(path, (error) => {
                        if (error) {
                            cb(this.convert(error, path));
                        }
                        else {
                            cb(null);
                        }
                    });
                }
            }
        });
    }
    /**
     * Delete a file
     */
    unlink(path, cb) {
        this._remove(path, cb, true);
    }
    /**
     * Delete a directory
     */
    rmdir(path, cb) {
        this._remove(path, cb, false);
    }
    /**
     * Create a directory
     */
    mkdir(p, mode, cb) {
        // Dropbox.js' client.mkdir() behaves like `mkdir -p`, i.e. it creates a
        // directory and all its ancestors if they don't exist.
        // Node's fs.mkdir() behaves like `mkdir`, i.e. it throws an error if an attempt
        // is made to create a directory without a parent.
        // To handle this inconsistency, a check for the existence of `path`'s parent
        // must be performed before it is created, and an error thrown if it does
        // not exist
        const parent = path.dirname(p);
        this._client.stat(parent, (error, stat) => {
            if (error) {
                cb(this.convert(error, parent));
            }
            else {
                this._client.mkdir(p, (error) => {
                    if (error) {
                        cb(ApiError.FileError(ErrorCode.EEXIST, p));
                    }
                    else {
                        cb(null);
                    }
                });
            }
        });
    }
    /**
     * Get the names of the files in a directory
     */
    readdir(path, cb) {
        this._client.readdir(path, (error, files) => {
            if (error) {
                return cb(this.convert(error));
            }
            else {
                return cb(null, files);
            }
        });
    }
    /**
     * Converts a Dropbox-JS error into a BFS error.
     */
    convert(err, path = null) {
        let errorCode = errorCodeLookup[err.status];
        if (errorCode === undefined) {
            errorCode = ErrorCode.EIO;
        }
        if (!path) {
            return new ApiError(errorCode);
        }
        else {
            return ApiError.FileError(errorCode, path);
        }
    }
}
DropboxFileSystem.Name = "Dropbox";
DropboxFileSystem.Options = {
    client: {
        type: "object",
        description: "An *authenticated* Dropbox client. Must be from the 0.10 JS SDK.",
        validator: (opt, cb) => {
            if (opt.isAuthenticated && opt.isAuthenticated()) {
                cb();
            }
            else {
                cb(new ApiError(ErrorCode.EINVAL, `'client' option must be an authenticated Dropbox client from the v0.10 JS SDK.`));
            }
        }
    }
};
//# sourceMappingURL=Dropbox.js.map