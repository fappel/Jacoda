/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, EventEmitter, Inject, InjectionToken, Optional } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
/** @type {?} */
export const TRANSLATE_SETTINGS = new InjectionToken('TRANSLATE_SETTINGS');
/**
 * @record
 */
export function TranslateParams() { }
export class TranslateService {
    /**
     * @param {?} http
     * @param {?} settings
     */
    constructor(http, settings) {
        this.http = http;
        this.data = {};
        this._fallbackLang = 'en';
        this._translationRoot = 'assets/i18n';
        /**
         * Raised each time active language gets changed.
         */
        this.activeLangChanged = new EventEmitter();
        /**
         * Toggles debug mode.
         *
         * When in the debug mode, the service automatically prepends active language id to very translated result.
         * That allows to verify that your components support i18n correctly and do not contain hard-coded text.
         */
        this.debugMode = false;
        /**
         * Disable caching and always download language files.
         *
         * Applies cache busting query parameters to urls, for example: '?v=1522426955882'.
         */
        this.disableCache = false;
        /**
         * List of supported languages.
         *
         * The service will attempt to load resource files only for given set of languages,
         * and will automatically use fallback language for all unspecified values.
         *
         * By default this property is empty and service is going to probe all language files.
         * Active and Fallback languages are always taken into account even if you do not specify them in the list.
         */
        this.supportedLangs = [];
        /**
         * List of extra paths to look for translation files.
         *
         * By default this property is empty.
         * The value of `translationRoot` property is always taken into account.
         */
        this.translatePaths = [];
        this.applySettings(settings);
    }
    /**
     * The fallback language to use when a resource string for the active language is not available.
     * @return {?}
     */
    get fallbackLang() {
        return this._fallbackLang;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set fallbackLang(value) {
        this._fallbackLang = value || 'en';
    }
    /**
     * The language to use for the translations.
     * @return {?}
     */
    get activeLang() {
        return this._activeLang;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set activeLang(value) {
        /** @type {?} */
        const previousValue = this._activeLang;
        /** @type {?} */
        const newValue = value || this.fallbackLang;
        /** @type {?} */
        const changed = newValue !== previousValue;
        if (changed) {
            this._activeLang = newValue;
            this.use(newValue).then(() => {
                this.activeLangChanged.next({
                    previousValue: previousValue,
                    currentValue: newValue
                });
            });
        }
    }
    /**
     * @return {?}
     */
    getBrowserLanguage() {
        const [lang /*, locale*/] = navigator.language
            .replace('-', '_')
            .toLowerCase()
            .split('_');
        return lang;
    }
    /**
     * The root path to use when loading default translation files.
     * Defaults to 'assets/i18n'.
     * @return {?}
     */
    get translationRoot() {
        return this._translationRoot;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set translationRoot(value) {
        this._translationRoot = value || 'assets/i18n';
    }
    /**
     * @param {?} settings
     * @return {?}
     */
    applySettings(settings) {
        const { debugMode, disableCache, supportedLangs, translatePaths, translationRoot, activeLang } = this;
        /** @type {?} */
        const defaults = Object.assign({ debugMode,
            disableCache,
            supportedLangs,
            translatePaths,
            translationRoot,
            activeLang }, settings);
        this.debugMode = defaults.debugMode;
        this.disableCache = defaults.disableCache;
        this.supportedLangs = defaults.supportedLangs;
        this.translatePaths = defaults.translatePaths;
        this.translationRoot = defaults.translationRoot;
        this._activeLang = defaults.activeLang || this.getBrowserLanguage();
    }
    /**
     * Get translated string
     *
     * \@memberof TranslateService
     * @param {?} key Translation key
     * @param {?=} params
     * @param {?=} lang
     * @return {?} Translated string
     */
    get(key, params, lang) {
        if (key) {
            /** @type {?} */
            let value = this.getValue(lang || this.activeLang, key);
            if (value === key) {
                value = this.getValue(this.fallbackLang, key);
            }
            return this.format(value, params);
        }
        else {
            return null;
        }
    }
    /**
     * @return {?}
     */
    load() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.use(this.fallbackLang);
            return this.use(this.activeLang);
        });
    }
    /**
     * Load the translation file or use provided data for the given language.
     *
     * \@memberof TranslateService
     * @param {?} lang Language name
     * @param {?=} data
     * @return {?} Final translation data merged with existing translations
     */
    use(lang, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (lang && data) {
                return this.setTranslation(lang, data);
            }
            /** @type {?} */
            let translation = this.data[lang];
            if (this.isNotSupported(lang)) {
                translation = this.data[this.fallbackLang];
            }
            if (translation && Object.keys(translation).length > 0) {
                return translation;
            }
            /** @type {?} */
            const fileName = `${lang || this.fallbackLang}.json`;
            /** @type {?} */
            const filePaths = [this.translationRoot, ...(this.translatePaths || [])];
            for (const path of filePaths) {
                /** @type {?} */
                const filePath = `${path}/${fileName}`;
                yield this.loadTranslation(lang, filePath);
            }
            return this.data[lang] || {};
        });
    }
    /**
     * @param {?} lang
     * @param {?} path
     * @return {?}
     */
    loadTranslation(lang, path) {
        return new Promise(resolve => {
            if (this.disableCache) {
                path += `?v=${Date.now()}`;
            }
            this.http.get(path).subscribe(json => {
                resolve(this.setTranslation(lang, json));
            }, () => {
                resolve(this.data[lang] || {});
            });
        });
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    isNotSupported(lang) {
        return (lang !== this.fallbackLang &&
            lang !== this.activeLang &&
            (this.supportedLangs &&
                this.supportedLangs.length > 0 &&
                !this.supportedLangs.includes(lang)));
    }
    /**
     * @param {?} lang
     * @param {?} key
     * @return {?}
     */
    getValue(lang, key) {
        /** @type {?} */
        let data = this.data[lang];
        if (this.isNotSupported(lang)) {
            data = this.data[this.fallbackLang];
        }
        if (!data) {
            return key;
        }
        /** @type {?} */
        const keys = key.split('.');
        /** @type {?} */
        let propKey = '';
        do {
            propKey += keys.shift();
            /** @type {?} */
            const value = data[propKey];
            if (value !== undefined && (typeof value === 'object' || !keys.length)) {
                data = value;
                propKey = '';
            }
            else if (!keys.length) {
                data = key;
            }
            else {
                propKey += '.';
            }
        } while (keys.length);
        return data;
    }
    /**
     * @param {?} lang
     * @param {?} data
     * @return {?}
     */
    setTranslation(lang, data) {
        /** @type {?} */
        let finalResult = this.data[lang] || {};
        finalResult = this.merge(finalResult, data || {});
        this.data[lang] = finalResult;
        return finalResult;
    }
    /**
     * @param {...?} translations
     * @return {?}
     */
    merge(...translations) {
        /** @type {?} */
        const result = {};
        translations.forEach(translation => {
            Object.keys(translation).forEach(key => {
                if (key in result && Array.isArray(result[key])) {
                    result[key] = result[key].concat(translation[key]);
                }
                else if (key in result && typeof result[key] === 'object') {
                    result[key] = this.merge(result[key], translation[key]);
                }
                else {
                    result[key] = translation[key];
                }
            });
        });
        return result;
    }
    /**
     * @param {?} str
     * @param {?} params
     * @return {?}
     */
    format(str, params) {
        /** @type {?} */
        let result = str;
        if (params) {
            Object.keys(params).forEach(key => {
                /** @type {?} */
                const value = params[key];
                /** @type {?} */
                const template = new RegExp('{' + key + '}', 'gm');
                result = result.replace(template, value);
            });
        }
        if (this.debugMode) {
            result = `[${this.activeLang}] ${result}`;
        }
        return result;
    }
}
TranslateService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TranslateService.ctorParameters = () => [
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLATE_SETTINGS,] }] }
];
/** @nocollapse */ TranslateService.ngInjectableDef = i0.defineInjectable({ factory: function TranslateService_Factory() { return new TranslateService(i0.inject(i1.HttpClient), i0.inject(TRANSLATE_SETTINGS, 8)); }, token: TranslateService, providedIn: "root" });
if (false) {
    /** @type {?} */
    TranslateService.prototype.data;
    /** @type {?} */
    TranslateService.prototype._fallbackLang;
    /** @type {?} */
    TranslateService.prototype._activeLang;
    /** @type {?} */
    TranslateService.prototype._translationRoot;
    /**
     * Raised each time active language gets changed.
     * @type {?}
     */
    TranslateService.prototype.activeLangChanged;
    /**
     * Toggles debug mode.
     *
     * When in the debug mode, the service automatically prepends active language id to very translated result.
     * That allows to verify that your components support i18n correctly and do not contain hard-coded text.
     * @type {?}
     */
    TranslateService.prototype.debugMode;
    /**
     * Disable caching and always download language files.
     *
     * Applies cache busting query parameters to urls, for example: '?v=1522426955882'.
     * @type {?}
     */
    TranslateService.prototype.disableCache;
    /**
     * List of supported languages.
     *
     * The service will attempt to load resource files only for given set of languages,
     * and will automatically use fallback language for all unspecified values.
     *
     * By default this property is empty and service is going to probe all language files.
     * Active and Fallback languages are always taken into account even if you do not specify them in the list.
     * @type {?}
     */
    TranslateService.prototype.supportedLangs;
    /**
     * List of extra paths to look for translation files.
     *
     * By default this property is empty.
     * The value of `translationRoot` property is always taken into account.
     * @type {?}
     */
    TranslateService.prototype.translatePaths;
    /** @type {?} */
    TranslateService.prototype.http;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmdzdGFjay90cmFuc2xhdGUvIiwic291cmNlcyI6WyJsaWIvdHJhbnNsYXRlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQ0wsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sY0FBYyxFQUNkLFFBQVEsRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7Ozs7QUFHbEQsTUFBTSxPQUFPLGtCQUFrQixHQUFHLElBQUksY0FBYyxDQUNsRCxvQkFBb0IsQ0FDckI7Ozs7QUFFRCxxQ0FFQztBQUtELE1BQU0sT0FBTyxnQkFBZ0I7Ozs7O0lBc0czQixZQUNVLElBQWdCLEVBR3hCLFFBQTJCO1FBSG5CLFNBQUksR0FBSixJQUFJLENBQVk7UUF0R2hCLFNBQUksR0FBMkIsRUFBRSxDQUFDO1FBQ3BDLGtCQUFhLEdBQUcsSUFBSSxDQUFDO1FBRXJCLHFCQUFnQixHQUFHLGFBQWEsQ0FBQzs7OztRQUt6QyxzQkFBaUIsR0FBRyxJQUFJLFlBQVksRUFHaEMsQ0FBQzs7Ozs7OztRQVFMLGNBQVMsR0FBRyxLQUFLLENBQUM7Ozs7OztRQU9sQixpQkFBWSxHQUFHLEtBQUssQ0FBQzs7Ozs7Ozs7OztRQVdyQixtQkFBYyxHQUFhLEVBQUUsQ0FBQzs7Ozs7OztRQVE5QixtQkFBYyxHQUFhLEVBQUUsQ0FBQztRQThENUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMvQixDQUFDOzs7OztJQTFERCxJQUFJLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDNUIsQ0FBQzs7Ozs7SUFFRCxJQUFJLFlBQVksQ0FBQyxLQUFhO1FBQzVCLElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxJQUFJLElBQUksQ0FBQztJQUNyQyxDQUFDOzs7OztJQUtELElBQUks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QXhHNUIsZ0NBQTRDOztJQUM1Qyx5Q0FBNkI7O0lBQzdCLHVDQUFvQjs7SUFDcEIsNENBQXlDOzs7OztJQUt6Qyw2Q0FHSzs7Ozs7Ozs7SUFRTCxxQ0FBa0I7Ozs7Ozs7SUFPbEIsd0NBQXFCOzs7Ozs7Ozs7OztJQVdyQiwwQ0FBOEI7Ozs7Ozs7O0lBUTlCLDBDQUE4Qjs7SUF5RDVCLGdDQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEluamVjdGFibGUsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0LFxuICBJbmplY3Rpb25Ub2tlbixcbiAgT3B0aW9uYWxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgVHJhbnNsYXRlU2V0dGluZ3MgfSBmcm9tICcuL3RyYW5zbGF0ZS5zZXR0aW5ncyc7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0xBVEVfU0VUVElOR1MgPSBuZXcgSW5qZWN0aW9uVG9rZW48VHJhbnNsYXRlU2V0dGluZ3M+KFxuICAnVFJBTlNMQVRFX1NFVFRJTkdTJ1xuKTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGVQYXJhbXMge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XG59XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0ZVNlcnZpY2Uge1xuICBwcm90ZWN0ZWQgZGF0YTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICBwcml2YXRlIF9mYWxsYmFja0xhbmcgPSAnZW4nO1xuICBwcml2YXRlIF9hY3RpdmVMYW5nO1xuICBwcml2YXRlIF90cmFuc2xhdGlvblJvb3QgPSAnYXNzZXRzL2kxOG4nO1xuXG4gIC8qKlxuICAgKiBSYWlzZWQgZWFjaCB0aW1lIGFjdGl2ZSBsYW5ndWFnZSBnZXRzIGNoYW5nZWQuXG4gICAqL1xuICBhY3RpdmVMYW5nQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8e1xuICAgIHByZXZpb3VzVmFsdWU6IHN0cmluZztcbiAgICBjdXJyZW50VmFsdWU6IHN0cmluZztcbiAgfT4oKTtcblxuICAvKipcbiAgICogVG9nZ2xlcyBkZWJ1ZyBtb2RlLlxuICAgKlxuICAgKiBXaGVuIGluIHRoZSBkZWJ1ZyBtb2RlLCB0aGUgc2VydmljZSBhdXRvbWF0aWNhbGx5IHByZXBlbmRzIGFjdGl2ZSBsYW5ndWFnZSBpZCB0byB2ZXJ5IHRyYW5zbGF0ZWQgcmVzdWx0LlxuICAgKiBUaGF0IGFsbG93cyB0byB2ZXJpZnkgdGhhdCB5b3VyIGNvbXBvbmVudHMgc3VwcG9ydCBpMThuIGNvcnJlY3RseSBhbmQgZG8gbm90IGNvbnRhaW4gaGFyZC1jb2RlZCB0ZXh0LlxuICAgKi9cbiAgZGVidWdNb2RlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIERpc2FibGUgY2FjaGluZyBhbmQgYWx3YXlzIGRvd25sb2FkIGxhbmd1YWdlIGZpbGVzLlxuICAgKlxuICAgKiBBcHBsaWVzIGNhY2hlIGJ1c3RpbmcgcXVlcnkgcGFyYW1ldGVycyB0byB1cmxzLCBmb3IgZXhhbXBsZTogJz92PTE1MjI0MjY5NTU4ODInLlxuICAgKi9cbiAgZGlzYWJsZUNhY2hlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygc3VwcG9ydGVkIGxhbmd1YWdlcy5cbiAgICpcbiAgICogVGhlIHNlcnZpY2Ugd2lsbCBhdHRlbXB0IHRvIGxvYWQgcmVzb3VyY2UgZmlsZXMgb25seSBmb3IgZ2l2ZW4gc2V0IG9mIGxhbmd1YWdlcyxcbiAgICogYW5kIHdpbGwgYXV0b21hdGljYWxseSB1c2UgZmFsbGJhY2sgbGFuZ3VhZ2UgZm9yIGFsbCB1bnNwZWNpZmllZCB2YWx1ZXMuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBwcm9wZXJ0eSBpcyBlbXB0eSBhbmQgc2VydmljZSBpcyBnb2luZyB0byBwcm9iZSBhbGwgbGFuZ3VhZ2UgZmlsZXMuXG4gICAqIEFjdGl2ZSBhbmQgRmFsbGJhY2sgbGFuZ3VhZ2VzIGFyZSBhbHdheXMgdGFrZW4gaW50byBhY2NvdW50IGV2ZW4gaWYgeW91IGRvIG5vdCBzcGVjaWZ5IHRoZW0gaW4gdGhlIGxpc3QuXG4gICAqL1xuICBzdXBwb3J0ZWRMYW5nczogc3RyaW5nW10gPSBbXTtcblxuICAvKipcbiAgICogTGlzdCBvZiBleHRyYSBwYXRocyB0byBsb29rIGZvciB0cmFuc2xhdGlvbiBmaWxlcy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIHByb3BlcnR5IGlzIGVtcHR5LlxuICAgKiBUaGUgdmFsdWUgb2YgYHRyYW5zbGF0aW9uUm9vdGAgcHJvcGVydHkgaXMgYWx3YXlzIHRha2VuIGludG8gYWNjb3VudC5cbiAgICovXG4gIHRyYW5zbGF0ZVBhdGhzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgZmFsbGJhY2sgbGFuZ3VhZ2UgdG8gdXNlIHdoZW4gYSByZXNvdXJjZSBzdHJpbmcgZm9yIHRoZSBhY3RpdmUgbGFuZ3VhZ2UgaXMgbm90IGF2YWlsYWJsZS5cbiAgICovXG4gIGdldCBmYWxsYmFja0xhbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tMYW5nO1xuICB9XG5cbiAgc2V0IGZhbGxiYWNrTGFuZyh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fZmFsbGJhY2tMYW5nID0gdmFsdWUgfHwgJ2VuJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGFuZ3VhZ2UgdG8gdXNlIGZvciB0aGUgdHJhbnNsYXRpb25zLlxuICAgKi9cbiAgZ2V0IGFjdGl2ZUxhbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlTGFuZztcbiAgfVxuXG4gIHNldCBhY3RpdmVMYW5nKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fYWN0aXZlTGFuZztcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlIHx8IHRoaXMuZmFsbGJhY2tMYW5nO1xuICAgIGNvbnN0IGNoYW5nZWQgPSBuZXdWYWx1ZSAhPT0gcHJldmlvdXNWYWx1ZTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmVMYW5nID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLnVzZShuZXdWYWx1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuYWN0aXZlTGFuZ0NoYW5nZWQubmV4dCh7XG4gICAgICAgICAgcHJldmlvdXNWYWx1ZTogcHJldmlvdXNWYWx1ZSxcbiAgICAgICAgICBjdXJyZW50VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QnJvd3Nlckxhbmd1YWdlKCk6IHN0cmluZyB7XG4gICAgY29uc3QgW2xhbmcgLyosIGxvY2FsZSovXSA9IG5hdmlnYXRvci5sYW5ndWFnZVxuICAgICAgLnJlcGxhY2UoJy0nLCAnXycpXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgLnNwbGl0KCdfJyk7XG4gICAgcmV0dXJuIGxhbmc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJvb3QgcGF0aCB0byB1c2Ugd2hlbiBsb2FkaW5nIGRlZmF1bHQgdHJhbnNsYXRpb24gZmlsZXMuXG4gICAqIERlZmF1bHRzIHRvICdhc3NldHMvaTE4bicuXG4gICAqL1xuICBnZXQgdHJhbnNsYXRpb25Sb290KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zbGF0aW9uUm9vdDtcbiAgfVxuXG4gIHNldCB0cmFuc2xhdGlvblJvb3QodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX3RyYW5zbGF0aW9uUm9vdCA9IHZhbHVlIHx8ICdhc3NldHMvaTE4bic7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGh0dHA6IEh0dHBDbGllbnQsXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KFRSQU5TTEFURV9TRVRUSU5HUylcbiAgICBzZXR0aW5nczogVHJhbnNsYXRlU2V0dGluZ3NcbiAgKSB7XG4gICAgdGhpcy5hcHBseVNldHRpbmdzKHNldHRpbmdzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBseVNldHRpbmdzKHNldHRpbmdzOiBUcmFuc2xhdGVTZXR0aW5ncykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlYnVnTW9kZSxcbiAgICAgIGRpc2FibGVDYWNoZSxcbiAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgdHJhbnNsYXRlUGF0aHMsXG4gICAgICB0cmFuc2xhdGlvblJvb3QsXG4gICAgICBhY3RpdmVMYW5nXG4gICAgfSA9IHRoaXM7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIGRlYnVnTW9kZSxcbiAgICAgIGRpc2FibGVDYWNoZSxcbiAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgdHJhbnNsYXRlUGF0aHMsXG4gICAgICB0cmFuc2xhdGlvblJvb3QsXG4gICAgICBhY3RpdmVMYW5nLFxuICAgICAgLi4uc2V0dGluZ3NcbiAgICB9O1xuXG4gICAgdGhpcy5kZWJ1Z01vZGUgPSBkZWZhdWx0cy5kZWJ1Z01vZGU7XG4gICAgdGhpcy5kaXNhYmxlQ2FjaGUgPSBkZWZhdWx0cy5kaXNhYmxlQ2FjaGU7XG4gICAgdGhpcy5zdXBwb3J0ZWRMYW5ncyA9IGRlZmF1bHRzLnN1cHBvcnRlZExhbmdzO1xuICAgIHRoaXMudHJhbnNsYXRlUGF0aHMgPSBkZWZhdWx0cy50cmFuc2xhdGVQYXRocztcbiAgICB0aGlzLnRyYW5zbGF0aW9uUm9vdCA9IGRlZmF1bHRzLnRyYW5zbGF0aW9uUm9vdDtcbiAgICB0aGlzLl9hY3RpdmVMYW5nID0gZGVmYXVsdHMuYWN0aXZlTGFuZyB8fCB0aGlzLmdldEJyb3dzZXJMYW5ndWFnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2xhdGVkIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRyYW5zbGF0aW9uIGtleVxuICAgKiBAcGFyYW0gW3BhcmFtc10gVHJhbnNsYXRpb24gcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gW2xhbmddIExhbmd1YWdlIHRvIHVzZSBmb3IgdHJhbnNsYXRpb25cbiAgICogQHJldHVybnMgVHJhbnNsYXRlZCBzdHJpbmdcbiAgICogQG1lbWJlcm9mIFRyYW5zbGF0ZVNlcnZpY2VcbiAgICovXG4gIGdldChrZXk6IHN0cmluZywgcGFyYW1zPzogVHJhbnNsYXRlUGFyYW1zLCBsYW5nPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGxhbmcgfHwgdGhpcy5hY3RpdmVMYW5nLCBrZXkpO1xuICAgICAgaWYgKHZhbHVlID09PSBrZXkpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldFZhbHVlKHRoaXMuZmFsbGJhY2tMYW5nLCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHZhbHVlLCBwYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBsb2FkKCk6IFByb21pc2U8YW55PiB7XG4gICAgYXdhaXQgdGhpcy51c2UodGhpcy5mYWxsYmFja0xhbmcpO1xuICAgIHJldHVybiB0aGlzLnVzZSh0aGlzLmFjdGl2ZUxhbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIHRyYW5zbGF0aW9uIGZpbGUgb3IgdXNlIHByb3ZpZGVkIGRhdGEgZm9yIHRoZSBnaXZlbiBsYW5ndWFnZS5cbiAgICpcbiAgICogQHBhcmFtIGxhbmcgTGFuZ3VhZ2UgbmFtZVxuICAgKiBAcGFyYW0gW2RhdGFdIFRyYW5zbGF0aW9uIGRhdGEgdG8gdXNlXG4gICAqIEByZXR1cm5zIEZpbmFsIHRyYW5zbGF0aW9uIGRhdGEgbWVyZ2VkIHdpdGggZXhpc3RpbmcgdHJhbnNsYXRpb25zXG4gICAqIEBtZW1iZXJvZiBUcmFuc2xhdGVTZXJ2aWNlXG4gICAqL1xuICBhc3luYyB1c2UobGFuZzogc3RyaW5nLCBkYXRhPzogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAobGFuZyAmJiBkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRUcmFuc2xhdGlvbihsYW5nLCBkYXRhKTtcbiAgICB9XG5cbiAgICBsZXQgdHJhbnNsYXRpb24gPSB0aGlzLmRhdGFbbGFuZ107XG4gICAgaWYgKHRoaXMuaXNOb3RTdXBwb3J0ZWQobGFuZykpIHtcbiAgICAgIHRyYW5zbGF0aW9uID0gdGhpcy5kYXRhW3RoaXMuZmFsbGJhY2tMYW5nXTtcbiAgICB9XG5cbiAgICBpZiAodHJhbnNsYXRpb24gJiYgT2JqZWN0LmtleXModHJhbnNsYXRpb24pLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0cmFuc2xhdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlTmFtZSA9IGAke2xhbmcgfHwgdGhpcy5mYWxsYmFja0xhbmd9Lmpzb25gO1xuICAgIGNvbnN0IGZpbGVQYXRocyA9IFt0aGlzLnRyYW5zbGF0aW9uUm9vdCwgLi4uKHRoaXMudHJhbnNsYXRlUGF0aHMgfHwgW10pXTtcblxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBmaWxlUGF0aHMpIHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gYCR7cGF0aH0vJHtmaWxlTmFtZX1gO1xuICAgICAgYXdhaXQgdGhpcy5sb2FkVHJhbnNsYXRpb24obGFuZywgZmlsZVBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFbbGFuZ10gfHwge307XG4gIH1cblxuICBwcm90ZWN0ZWQgbG9hZFRyYW5zbGF0aW9uKGxhbmc6IHN0cmluZywgcGF0aDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8YW55PihyZXNvbHZlID0+IHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVDYWNoZSkge1xuICAgICAgICBwYXRoICs9IGA/dj0ke0RhdGUubm93KCl9YDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5odHRwLmdldDx7fT4ocGF0aCkuc3Vic2NyaWJlKFxuICAgICAgICBqc29uID0+IHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMuc2V0VHJhbnNsYXRpb24obGFuZywganNvbikpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLmRhdGFbbGFuZ10gfHwge30pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGlzTm90U3VwcG9ydGVkKGxhbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgbGFuZyAhPT0gdGhpcy5mYWxsYmFja0xhbmcgJiZcbiAgICAgIGxhbmcgIT09IHRoaXMuYWN0aXZlTGFuZyAmJlxuICAgICAgKHRoaXMuc3VwcG9ydGVkTGFuZ3MgJiZcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRMYW5ncy5sZW5ndGggPiAwICYmXG4gICAgICAgICF0aGlzLnN1cHBvcnRlZExhbmdzLmluY2x1ZGVzKGxhbmcpKVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0VmFsdWUobGFuZzogc3RyaW5nLCBrZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmRhdGFbbGFuZ107XG4gICAgaWYgKHRoaXMuaXNOb3RTdXBwb3J0ZWQobGFuZykpIHtcbiAgICAgIGRhdGEgPSB0aGlzLmRhdGFbdGhpcy5mYWxsYmFja0xhbmddO1xuICAgIH1cblxuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgbGV0IHByb3BLZXkgPSAnJztcblxuICAgIGRvIHtcbiAgICAgIHByb3BLZXkgKz0ga2V5cy5zaGlmdCgpO1xuICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW3Byb3BLZXldO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgIWtleXMubGVuZ3RoKSkge1xuICAgICAgICBkYXRhID0gdmFsdWU7XG4gICAgICAgIHByb3BLZXkgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBrZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wS2V5ICs9ICcuJztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChrZXlzLmxlbmd0aCk7XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXRUcmFuc2xhdGlvbihsYW5nOiBzdHJpbmcsIGRhdGE6IGFueSk6IGFueSB7XG4gICAgbGV0IGZpbmFsUmVzdWx0ID0gdGhpcy5kYXRhW2xhbmddIHx8IHt9O1xuICAgIGZpbmFsUmVzdWx0ID0gdGhpcy5tZXJnZShmaW5hbFJlc3VsdCwgZGF0YSB8fCB7fSk7XG4gICAgdGhpcy5kYXRhW2xhbmddID0gZmluYWxSZXN1bHQ7XG4gICAgcmV0dXJuIGZpbmFsUmVzdWx0O1xuICB9XG5cbiAgcHJvdGVjdGVkIG1lcmdlKC4uLnRyYW5zbGF0aW9ucyk6IGFueSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICB0cmFuc2xhdGlvbnMuZm9yRWFjaCh0cmFuc2xhdGlvbiA9PiB7XG4gICAgICBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5IGluIHJlc3VsdCAmJiBBcnJheS5pc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gcmVzdWx0W2tleV0uY29uY2F0KHRyYW5zbGF0aW9uW2tleV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiByZXN1bHQgJiYgdHlwZW9mIHJlc3VsdFtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5tZXJnZShyZXN1bHRba2V5XSwgdHJhbnNsYXRpb25ba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0cmFuc2xhdGlvbltrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgZm9ybWF0KHN0cjogc3RyaW5nLCBwYXJhbXM6IFRyYW5zbGF0ZVBhcmFtcyk6IHN0cmluZyB7XG4gICAgbGV0IHJlc3VsdCA9IHN0cjtcblxuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IG5ldyBSZWdFeHAoJ3snICsga2V5ICsgJ30nLCAnZ20nKTtcblxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSh0ZW1wbGF0ZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICByZXN1bHQgPSBgWyR7dGhpcy5hY3RpdmVMYW5nfV0gJHtyZXN1bHR9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iXX0=