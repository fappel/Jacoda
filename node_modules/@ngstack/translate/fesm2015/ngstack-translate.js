import { __awaiter } from 'tslib';
import { Injectable, EventEmitter, Inject, InjectionToken, Optional, NgModule, Pipe, defineInjectable, inject } from '@angular/core';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { Title } from '@angular/platform-browser';
import { Subject } from 'rxjs';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const TRANSLATE_SETTINGS = new InjectionToken('TRANSLATE_SETTINGS');
class TranslateService {
    /**
     * @param {?} http
     * @param {?} settings
     */
    constructor(http, settings) {
        this.http = http;
        this.data = {};
        this._fallbackLang = 'en';
        this._translationRoot = 'assets/i18n';
        /**
         * Raised each time active language gets changed.
         */
        this.activeLangChanged = new EventEmitter();
        /**
         * Toggles debug mode.
         *
         * When in the debug mode, the service automatically prepends active language id to very translated result.
         * That allows to verify that your components support i18n correctly and do not contain hard-coded text.
         */
        this.debugMode = false;
        /**
         * Disable caching and always download language files.
         *
         * Applies cache busting query parameters to urls, for example: '?v=1522426955882'.
         */
        this.disableCache = false;
        /**
         * List of supported languages.
         *
         * The service will attempt to load resource files only for given set of languages,
         * and will automatically use fallback language for all unspecified values.
         *
         * By default this property is empty and service is going to probe all language files.
         * Active and Fallback languages are always taken into account even if you do not specify them in the list.
         */
        this.supportedLangs = [];
        /**
         * List of extra paths to look for translation files.
         *
         * By default this property is empty.
         * The value of `translationRoot` property is always taken into account.
         */
        this.translatePaths = [];
        this.applySettings(settings);
    }
    /**
     * The fallback language to use when a resource string for the active language is not available.
     * @return {?}
     */
    get fallbackLang() {
        return this._fallbackLang;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set fallbackLang(value) {
        this._fallbackLang = value || 'en';
    }
    /**
     * The language to use for the translations.
     * @return {?}
     */
    get activeLang() {
        return this._activeLang;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set activeLang(value) {
        /** @type {?} */
        const previousValue = this._activeLang;
        /** @type {?} */
        const newValue = value || this.fallbackLang;
        /** @type {?} */
        const changed = newValue !== previousValue;
        if (changed) {
            this._activeLang = newValue;
            this.use(newValue).then(() => {
                this.activeLangChanged.next({
                    previousValue: previousValue,
                    currentValue: newValue
                });
            });
        }
    }
    /**
     * @return {?}
     */
    getBrowserLanguage() {
        const [lang /*, locale*/] = navigator.language
            .replace('-', '_')
            .toLowerCase()
            .split('_');
        return lang;
    }
    /**
     * The root path to use when loading default translation files.
     * Defaults to 'assets/i18n'.
     * @return {?}
     */
    get translationRoot() {
        return this._translationRoot;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set translationRoot(value) {
        this._translationRoot = value || 'assets/i18n';
    }
    /**
     * @param {?} settings
     * @return {?}
     */
    applySettings(settings) {
        const { debugMode, disableCache, supportedLangs, translatePaths, translationRoot, activeLang } = this;
        /** @type {?} */
        const defaults = Object.assign({ debugMode,
            disableCache,
            supportedLangs,
            translatePaths,
            translationRoot,
            activeLang }, settings);
        this.debugMode = defaults.debugMode;
        this.disableCache = defaults.disableCache;
        this.supportedLangs = defaults.supportedLangs;
        this.translatePaths = defaults.translatePaths;
        this.translationRoot = defaults.translationRoot;
        this._activeLang = defaults.activeLang || this.getBrowserLanguage();
    }
    /**
     * Get translated string
     *
     * \@memberof TranslateService
     * @param {?} key Translation key
     * @param {?=} params
     * @param {?=} lang
     * @return {?} Translated string
     */
    get(key, params, lang) {
        if (key) {
            /** @type {?} */
            let value = this.getValue(lang || this.activeLang, key);
            if (value === key) {
                value = this.getValue(this.fallbackLang, key);
            }
            return this.format(value, params);
        }
        else {
            return null;
        }
    }
    /**
     * @return {?}
     */
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.use(this.fallbackLang);
            return this.use(this.activeLang);
        });
    }
    /**
     * Load the translation file or use provided data for the given language.
     *
     * \@memberof TranslateService
     * @param {?} lang Language name
     * @param {?=} data
     * @return {?} Final translation data merged with existing translations
     */
    use(lang, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (lang && data) {
                return this.setTranslation(lang, data);
            }
            /** @type {?} */
            let translation = this.data[lang];
            if (this.isNotSupported(lang)) {
                translation = this.data[this.fallbackLang];
            }
            if (translation && Object.keys(translation).length > 0) {
                return translation;
            }
            /** @type {?} */
            const fileName = `${lang || this.fallbackLang}.json`;
            /** @type {?} */
            const filePaths = [this.translationRoot, ...(this.translatePaths || [])];
            for (const path of filePaths) {
                /** @type {?} */
                const filePath = `${path}/${fileName}`;
                yield this.loadTranslation(lang, filePath);
            }
            return this.data[lang] || {};
        });
    }
    /**
     * @param {?} lang
     * @param {?} path
     * @return {?}
     */
    loadTranslation(lang, path) {
        return new Promise(resolve => {
            if (this.disableCache) {
                path += `?v=${Date.now()}`;
            }
            this.http.get(path).subscribe(json => {
                resolve(this.setTranslation(lang, json));
            }, () => {
                resolve(this.data[lang] || {});
            });
        });
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    isNotSupported(lang) {
        return (lang !== this.fallbackLang &&
            lang !== this.activeLang &&
            (this.supportedLangs &&
                this.supportedLangs.length > 0 &&
                !this.supportedLangs.includes(lang)));
    }
    /**
     * @param {?} lang
     * @param {?} key
     * @return {?}
     */
    getValue(lang, key) {
        /** @type {?} */
        let data = this.data[lang];
        if (this.isNotSupported(lang)) {
            data = this.data[this.fallbackLang];
        }
        if (!data) {
            return key;
        }
        /** @type {?} */
        const keys = key.split('.');
        /** @type {?} */
        let propKey = '';
        do {
            propKey += keys.shift();
            /** @type {?} */
            const value = data[propKey];
            if (value !== undefined && (typeof value === 'object' || !keys.length)) {
                data = value;
                propKey = '';
            }
            else if (!keys.length) {
                data = key;
            }
            else {
                propKey += '.';
            }
        } while (keys.length);
        return data;
    }
    /**
     * @param {?} lang
     * @param {?} data
     * @return {?}
     */
    setTranslation(lang, data) {
        /** @type {?} */
        let finalResult = this.data[lang] || {};
        finalResult = this.merge(finalResult, data || {});
        this.data[lang] = finalResult;
        return finalResult;
    }
    /**
     * @param {...?} translations
     * @return {?}
     */
    merge(...translations) {
        /** @type {?} */
        const result = {};
        translations.forEach(translation => {
            Object.keys(translation).forEach(key => {
                if (key in result && Array.isArray(result[key])) {
                    result[key] = result[key].concat(translation[key]);
                }
                else if (key in result && typeof result[key] === 'object') {
                    result[key] = this.merge(result[key], translation[key]);
                }
                else {
                    result[key] = translation[key];
                }
            });
        });
        return result;
    }
    /**
     * @param {?} str
     * @param {?} params
     * @return {?}
     */
    format(str, params) {
        /** @type {?} */
        let result = str;
        if (params) {
            Object.keys(params).forEach(key => {
                /** @type {?} */
                const value = params[key];
                /** @type {?} */
                const template = new RegExp('{' + key + '}', 'gm');
                result = result.replace(template, value);
            });
        }
        if (this.debugMode) {
            result = `[${this.activeLang}] ${result}`;
        }
        return result;
    }
}
TranslateService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TranslateService.ctorParameters = () => [
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLATE_SETTINGS,] }] }
];
/** @nocollapse */ TranslateService.ngInjectableDef = defineInjectable({ factory: function TranslateService_Factory() { return new TranslateService(inject(HttpClient), inject(TRANSLATE_SETTINGS, 8)); }, token: TranslateService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TitleService {
    /**
     * @param {?} title
     * @param {?} translate
     */
    constructor(title, translate) {
        this.title = title;
        this.translate = translate;
        this._titleKey = '';
        this.changed = new Subject();
        translate.activeLangChanged.subscribe(() => this.onLanguageChanged());
    }
    /**
     * @return {?}
     */
    getTitle() {
        return this._titleKey;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    setTitle(key) {
        /** @type {?} */
        const previousValue = this._titleKey;
        /** @type {?} */
        const newValue = key || '';
        /** @type {?} */
        const changed = newValue !== previousValue;
        if (changed) {
            this._titleKey = newValue;
            /** @type {?} */
            const translated = this.translate.get(newValue);
            this.title.setTitle(translated);
            this.changed.next({
                previousValue: previousValue,
                currentValue: newValue
            });
        }
    }
    /**
     * @return {?}
     */
    onLanguageChanged() {
        if (this._titleKey) {
            /** @type {?} */
            const translated = this.translate.get(this._titleKey);
            this.title.setTitle(translated);
        }
    }
}
TitleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TitleService.ctorParameters = () => [
    { type: Title },
    { type: TranslateService }
];
/** @nocollapse */ TitleService.ngInjectableDef = defineInjectable({ factory: function TitleService_Factory() { return new TitleService(inject(Title), inject(TranslateService)); }, token: TitleService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TranslatePipe {
    /**
     * @param {?} translate
     */
    constructor(translate) {
        this.translate = translate;
    }
    /**
     * @param {?} key
     * @param {?=} params
     * @return {?}
     */
    transform(key, params) {
        return this.translate.get(key, params);
    }
}
TranslatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'translate',
                pure: false
            },] }
];
/** @nocollapse */
TranslatePipe.ctorParameters = () => [
    { type: TranslateService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TranslateModule {
    /**
     * @param {?=} settings
     * @return {?}
     */
    static forRoot(settings) {
        return {
            ngModule: TranslateModule,
            providers: [
                { provide: TRANSLATE_SETTINGS, useValue: settings },
                TranslateService,
                TitleService
            ]
        };
    }
    /**
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: TranslateModule
        };
    }
}
TranslateModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, HttpClientModule],
                declarations: [TranslatePipe],
                exports: [TranslatePipe]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { TRANSLATE_SETTINGS, TranslateService, TitleService, TranslatePipe, TranslateModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmdzdGFjay10cmFuc2xhdGUuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuZ3N0YWNrL3RyYW5zbGF0ZS9saWIvdHJhbnNsYXRlLnNlcnZpY2UudHMiLCJuZzovL0BuZ3N0YWNrL3RyYW5zbGF0ZS9saWIvdGl0bGUuc2VydmljZS50cyIsIm5nOi8vQG5nc3RhY2svdHJhbnNsYXRlL2xpYi90cmFuc2xhdGUucGlwZS50cyIsIm5nOi8vQG5nc3RhY2svdHJhbnNsYXRlL2xpYi90cmFuc2xhdGUubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEluamVjdGFibGUsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0LFxuICBJbmplY3Rpb25Ub2tlbixcbiAgT3B0aW9uYWxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgVHJhbnNsYXRlU2V0dGluZ3MgfSBmcm9tICcuL3RyYW5zbGF0ZS5zZXR0aW5ncyc7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0xBVEVfU0VUVElOR1MgPSBuZXcgSW5qZWN0aW9uVG9rZW48VHJhbnNsYXRlU2V0dGluZ3M+KFxuICAnVFJBTlNMQVRFX1NFVFRJTkdTJ1xuKTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGVQYXJhbXMge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XG59XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0ZVNlcnZpY2Uge1xuICBwcm90ZWN0ZWQgZGF0YTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICBwcml2YXRlIF9mYWxsYmFja0xhbmcgPSAnZW4nO1xuICBwcml2YXRlIF9hY3RpdmVMYW5nO1xuICBwcml2YXRlIF90cmFuc2xhdGlvblJvb3QgPSAnYXNzZXRzL2kxOG4nO1xuXG4gIC8qKlxuICAgKiBSYWlzZWQgZWFjaCB0aW1lIGFjdGl2ZSBsYW5ndWFnZSBnZXRzIGNoYW5nZWQuXG4gICAqL1xuICBhY3RpdmVMYW5nQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8e1xuICAgIHByZXZpb3VzVmFsdWU6IHN0cmluZztcbiAgICBjdXJyZW50VmFsdWU6IHN0cmluZztcbiAgfT4oKTtcblxuICAvKipcbiAgICogVG9nZ2xlcyBkZWJ1ZyBtb2RlLlxuICAgKlxuICAgKiBXaGVuIGluIHRoZSBkZWJ1ZyBtb2RlLCB0aGUgc2VydmljZSBhdXRvbWF0aWNhbGx5IHByZXBlbmRzIGFjdGl2ZSBsYW5ndWFnZSBpZCB0byB2ZXJ5IHRyYW5zbGF0ZWQgcmVzdWx0LlxuICAgKiBUaGF0IGFsbG93cyB0byB2ZXJpZnkgdGhhdCB5b3VyIGNvbXBvbmVudHMgc3VwcG9ydCBpMThuIGNvcnJlY3RseSBhbmQgZG8gbm90IGNvbnRhaW4gaGFyZC1jb2RlZCB0ZXh0LlxuICAgKi9cbiAgZGVidWdNb2RlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIERpc2FibGUgY2FjaGluZyBhbmQgYWx3YXlzIGRvd25sb2FkIGxhbmd1YWdlIGZpbGVzLlxuICAgKlxuICAgKiBBcHBsaWVzIGNhY2hlIGJ1c3RpbmcgcXVlcnkgcGFyYW1ldGVycyB0byB1cmxzLCBmb3IgZXhhbXBsZTogJz92PTE1MjI0MjY5NTU4ODInLlxuICAgKi9cbiAgZGlzYWJsZUNhY2hlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygc3VwcG9ydGVkIGxhbmd1YWdlcy5cbiAgICpcbiAgICogVGhlIHNlcnZpY2Ugd2lsbCBhdHRlbXB0IHRvIGxvYWQgcmVzb3VyY2UgZmlsZXMgb25seSBmb3IgZ2l2ZW4gc2V0IG9mIGxhbmd1YWdlcyxcbiAgICogYW5kIHdpbGwgYXV0b21hdGljYWxseSB1c2UgZmFsbGJhY2sgbGFuZ3VhZ2UgZm9yIGFsbCB1bnNwZWNpZmllZCB2YWx1ZXMuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBwcm9wZXJ0eSBpcyBlbXB0eSBhbmQgc2VydmljZSBpcyBnb2luZyB0byBwcm9iZSBhbGwgbGFuZ3VhZ2UgZmlsZXMuXG4gICAqIEFjdGl2ZSBhbmQgRmFsbGJhY2sgbGFuZ3VhZ2VzIGFyZSBhbHdheXMgdGFrZW4gaW50byBhY2NvdW50IGV2ZW4gaWYgeW91IGRvIG5vdCBzcGVjaWZ5IHRoZW0gaW4gdGhlIGxpc3QuXG4gICAqL1xuICBzdXBwb3J0ZWRMYW5nczogc3RyaW5nW10gPSBbXTtcblxuICAvKipcbiAgICogTGlzdCBvZiBleHRyYSBwYXRocyB0byBsb29rIGZvciB0cmFuc2xhdGlvbiBmaWxlcy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIHByb3BlcnR5IGlzIGVtcHR5LlxuICAgKiBUaGUgdmFsdWUgb2YgYHRyYW5zbGF0aW9uUm9vdGAgcHJvcGVydHkgaXMgYWx3YXlzIHRha2VuIGludG8gYWNjb3VudC5cbiAgICovXG4gIHRyYW5zbGF0ZVBhdGhzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgZmFsbGJhY2sgbGFuZ3VhZ2UgdG8gdXNlIHdoZW4gYSByZXNvdXJjZSBzdHJpbmcgZm9yIHRoZSBhY3RpdmUgbGFuZ3VhZ2UgaXMgbm90IGF2YWlsYWJsZS5cbiAgICovXG4gIGdldCBmYWxsYmFja0xhbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tMYW5nO1xuICB9XG5cbiAgc2V0IGZhbGxiYWNrTGFuZyh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fZmFsbGJhY2tMYW5nID0gdmFsdWUgfHwgJ2VuJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGFuZ3VhZ2UgdG8gdXNlIGZvciB0aGUgdHJhbnNsYXRpb25zLlxuICAgKi9cbiAgZ2V0IGFjdGl2ZUxhbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlTGFuZztcbiAgfVxuXG4gIHNldCBhY3RpdmVMYW5nKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fYWN0aXZlTGFuZztcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlIHx8IHRoaXMuZmFsbGJhY2tMYW5nO1xuICAgIGNvbnN0IGNoYW5nZWQgPSBuZXdWYWx1ZSAhPT0gcHJldmlvdXNWYWx1ZTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmVMYW5nID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLnVzZShuZXdWYWx1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuYWN0aXZlTGFuZ0NoYW5nZWQubmV4dCh7XG4gICAgICAgICAgcHJldmlvdXNWYWx1ZTogcHJldmlvdXNWYWx1ZSxcbiAgICAgICAgICBjdXJyZW50VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QnJvd3Nlckxhbmd1YWdlKCk6IHN0cmluZyB7XG4gICAgY29uc3QgW2xhbmcgLyosIGxvY2FsZSovXSA9IG5hdmlnYXRvci5sYW5ndWFnZVxuICAgICAgLnJlcGxhY2UoJy0nLCAnXycpXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgLnNwbGl0KCdfJyk7XG4gICAgcmV0dXJuIGxhbmc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJvb3QgcGF0aCB0byB1c2Ugd2hlbiBsb2FkaW5nIGRlZmF1bHQgdHJhbnNsYXRpb24gZmlsZXMuXG4gICAqIERlZmF1bHRzIHRvICdhc3NldHMvaTE4bicuXG4gICAqL1xuICBnZXQgdHJhbnNsYXRpb25Sb290KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zbGF0aW9uUm9vdDtcbiAgfVxuXG4gIHNldCB0cmFuc2xhdGlvblJvb3QodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX3RyYW5zbGF0aW9uUm9vdCA9IHZhbHVlIHx8ICdhc3NldHMvaTE4bic7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGh0dHA6IEh0dHBDbGllbnQsXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KFRSQU5TTEFURV9TRVRUSU5HUylcbiAgICBzZXR0aW5nczogVHJhbnNsYXRlU2V0dGluZ3NcbiAgKSB7XG4gICAgdGhpcy5hcHBseVNldHRpbmdzKHNldHRpbmdzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBseVNldHRpbmdzKHNldHRpbmdzOiBUcmFuc2xhdGVTZXR0aW5ncykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlYnVnTW9kZSxcbiAgICAgIGRpc2FibGVDYWNoZSxcbiAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgdHJhbnNsYXRlUGF0aHMsXG4gICAgICB0cmFuc2xhdGlvblJvb3QsXG4gICAgICBhY3RpdmVMYW5nXG4gICAgfSA9IHRoaXM7XG5cbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIGRlYnVnTW9kZSxcbiAgICAgIGRpc2FibGVDYWNoZSxcbiAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgdHJhbnNsYXRlUGF0aHMsXG4gICAgICB0cmFuc2xhdGlvblJvb3QsXG4gICAgICBhY3RpdmVMYW5nLFxuICAgICAgLi4uc2V0dGluZ3NcbiAgICB9O1xuXG4gICAgdGhpcy5kZWJ1Z01vZGUgPSBkZWZhdWx0cy5kZWJ1Z01vZGU7XG4gICAgdGhpcy5kaXNhYmxlQ2FjaGUgPSBkZWZhdWx0cy5kaXNhYmxlQ2FjaGU7XG4gICAgdGhpcy5zdXBwb3J0ZWRMYW5ncyA9IGRlZmF1bHRzLnN1cHBvcnRlZExhbmdzO1xuICAgIHRoaXMudHJhbnNsYXRlUGF0aHMgPSBkZWZhdWx0cy50cmFuc2xhdGVQYXRocztcbiAgICB0aGlzLnRyYW5zbGF0aW9uUm9vdCA9IGRlZmF1bHRzLnRyYW5zbGF0aW9uUm9vdDtcbiAgICB0aGlzLl9hY3RpdmVMYW5nID0gZGVmYXVsdHMuYWN0aXZlTGFuZyB8fCB0aGlzLmdldEJyb3dzZXJMYW5ndWFnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2xhdGVkIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRyYW5zbGF0aW9uIGtleVxuICAgKiBAcGFyYW0gW3BhcmFtc10gVHJhbnNsYXRpb24gcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gW2xhbmddIExhbmd1YWdlIHRvIHVzZSBmb3IgdHJhbnNsYXRpb25cbiAgICogQHJldHVybnMgVHJhbnNsYXRlZCBzdHJpbmdcbiAgICogQG1lbWJlcm9mIFRyYW5zbGF0ZVNlcnZpY2VcbiAgICovXG4gIGdldChrZXk6IHN0cmluZywgcGFyYW1zPzogVHJhbnNsYXRlUGFyYW1zLCBsYW5nPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGxhbmcgfHwgdGhpcy5hY3RpdmVMYW5nLCBrZXkpO1xuICAgICAgaWYgKHZhbHVlID09PSBrZXkpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldFZhbHVlKHRoaXMuZmFsbGJhY2tMYW5nLCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHZhbHVlLCBwYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBsb2FkKCk6IFByb21pc2U8YW55PiB7XG4gICAgYXdhaXQgdGhpcy51c2UodGhpcy5mYWxsYmFja0xhbmcpO1xuICAgIHJldHVybiB0aGlzLnVzZSh0aGlzLmFjdGl2ZUxhbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIHRyYW5zbGF0aW9uIGZpbGUgb3IgdXNlIHByb3ZpZGVkIGRhdGEgZm9yIHRoZSBnaXZlbiBsYW5ndWFnZS5cbiAgICpcbiAgICogQHBhcmFtIGxhbmcgTGFuZ3VhZ2UgbmFtZVxuICAgKiBAcGFyYW0gW2RhdGFdIFRyYW5zbGF0aW9uIGRhdGEgdG8gdXNlXG4gICAqIEByZXR1cm5zIEZpbmFsIHRyYW5zbGF0aW9uIGRhdGEgbWVyZ2VkIHdpdGggZXhpc3RpbmcgdHJhbnNsYXRpb25zXG4gICAqIEBtZW1iZXJvZiBUcmFuc2xhdGVTZXJ2aWNlXG4gICAqL1xuICBhc3luYyB1c2UobGFuZzogc3RyaW5nLCBkYXRhPzogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAobGFuZyAmJiBkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRUcmFuc2xhdGlvbihsYW5nLCBkYXRhKTtcbiAgICB9XG5cbiAgICBsZXQgdHJhbnNsYXRpb24gPSB0aGlzLmRhdGFbbGFuZ107XG4gICAgaWYgKHRoaXMuaXNOb3RTdXBwb3J0ZWQobGFuZykpIHtcbiAgICAgIHRyYW5zbGF0aW9uID0gdGhpcy5kYXRhW3RoaXMuZmFsbGJhY2tMYW5nXTtcbiAgICB9XG5cbiAgICBpZiAodHJhbnNsYXRpb24gJiYgT2JqZWN0LmtleXModHJhbnNsYXRpb24pLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0cmFuc2xhdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlTmFtZSA9IGAke2xhbmcgfHwgdGhpcy5mYWxsYmFja0xhbmd9Lmpzb25gO1xuICAgIGNvbnN0IGZpbGVQYXRocyA9IFt0aGlzLnRyYW5zbGF0aW9uUm9vdCwgLi4uKHRoaXMudHJhbnNsYXRlUGF0aHMgfHwgW10pXTtcblxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBmaWxlUGF0aHMpIHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gYCR7cGF0aH0vJHtmaWxlTmFtZX1gO1xuICAgICAgYXdhaXQgdGhpcy5sb2FkVHJhbnNsYXRpb24obGFuZywgZmlsZVBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFbbGFuZ10gfHwge307XG4gIH1cblxuICBwcm90ZWN0ZWQgbG9hZFRyYW5zbGF0aW9uKGxhbmc6IHN0cmluZywgcGF0aDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8YW55PihyZXNvbHZlID0+IHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVDYWNoZSkge1xuICAgICAgICBwYXRoICs9IGA/dj0ke0RhdGUubm93KCl9YDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5odHRwLmdldDx7fT4ocGF0aCkuc3Vic2NyaWJlKFxuICAgICAgICBqc29uID0+IHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMuc2V0VHJhbnNsYXRpb24obGFuZywganNvbikpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLmRhdGFbbGFuZ10gfHwge30pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGlzTm90U3VwcG9ydGVkKGxhbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgbGFuZyAhPT0gdGhpcy5mYWxsYmFja0xhbmcgJiZcbiAgICAgIGxhbmcgIT09IHRoaXMuYWN0aXZlTGFuZyAmJlxuICAgICAgKHRoaXMuc3VwcG9ydGVkTGFuZ3MgJiZcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRMYW5ncy5sZW5ndGggPiAwICYmXG4gICAgICAgICF0aGlzLnN1cHBvcnRlZExhbmdzLmluY2x1ZGVzKGxhbmcpKVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0VmFsdWUobGFuZzogc3RyaW5nLCBrZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IGRhdGEgPSB0aGlzLmRhdGFbbGFuZ107XG4gICAgaWYgKHRoaXMuaXNOb3RTdXBwb3J0ZWQobGFuZykpIHtcbiAgICAgIGRhdGEgPSB0aGlzLmRhdGFbdGhpcy5mYWxsYmFja0xhbmddO1xuICAgIH1cblxuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgbGV0IHByb3BLZXkgPSAnJztcblxuICAgIGRvIHtcbiAgICAgIHByb3BLZXkgKz0ga2V5cy5zaGlmdCgpO1xuICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW3Byb3BLZXldO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgIWtleXMubGVuZ3RoKSkge1xuICAgICAgICBkYXRhID0gdmFsdWU7XG4gICAgICAgIHByb3BLZXkgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBrZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wS2V5ICs9ICcuJztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChrZXlzLmxlbmd0aCk7XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXRUcmFuc2xhdGlvbihsYW5nOiBzdHJpbmcsIGRhdGE6IGFueSk6IGFueSB7XG4gICAgbGV0IGZpbmFsUmVzdWx0ID0gdGhpcy5kYXRhW2xhbmddIHx8IHt9O1xuICAgIGZpbmFsUmVzdWx0ID0gdGhpcy5tZXJnZShmaW5hbFJlc3VsdCwgZGF0YSB8fCB7fSk7XG4gICAgdGhpcy5kYXRhW2xhbmddID0gZmluYWxSZXN1bHQ7XG4gICAgcmV0dXJuIGZpbmFsUmVzdWx0O1xuICB9XG5cbiAgcHJvdGVjdGVkIG1lcmdlKC4uLnRyYW5zbGF0aW9ucyk6IGFueSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICB0cmFuc2xhdGlvbnMuZm9yRWFjaCh0cmFuc2xhdGlvbiA9PiB7XG4gICAgICBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5IGluIHJlc3VsdCAmJiBBcnJheS5pc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gcmVzdWx0W2tleV0uY29uY2F0KHRyYW5zbGF0aW9uW2tleV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiByZXN1bHQgJiYgdHlwZW9mIHJlc3VsdFtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5tZXJnZShyZXN1bHRba2V5XSwgdHJhbnNsYXRpb25ba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0cmFuc2xhdGlvbltrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgZm9ybWF0KHN0cjogc3RyaW5nLCBwYXJhbXM6IFRyYW5zbGF0ZVBhcmFtcyk6IHN0cmluZyB7XG4gICAgbGV0IHJlc3VsdCA9IHN0cjtcblxuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IG5ldyBSZWdFeHAoJ3snICsga2V5ICsgJ30nLCAnZ20nKTtcblxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSh0ZW1wbGF0ZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICByZXN1bHQgPSBgWyR7dGhpcy5hY3RpdmVMYW5nfV0gJHtyZXN1bHR9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUaXRsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJy4vdHJhbnNsYXRlLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBUaXRsZVNlcnZpY2Uge1xuICBwcml2YXRlIF90aXRsZUtleSA9ICcnO1xuXG4gIGNoYW5nZWQgPSBuZXcgU3ViamVjdDx7XG4gICAgcHJldmlvdXNWYWx1ZTogc3RyaW5nO1xuICAgIGN1cnJlbnRWYWx1ZTogc3RyaW5nO1xuICB9PigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdGl0bGU6IFRpdGxlLCBwcml2YXRlIHRyYW5zbGF0ZTogVHJhbnNsYXRlU2VydmljZSkge1xuICAgIHRyYW5zbGF0ZS5hY3RpdmVMYW5nQ2hhbmdlZC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5vbkxhbmd1YWdlQ2hhbmdlZCgpKTtcbiAgfVxuXG4gIGdldFRpdGxlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3RpdGxlS2V5O1xuICB9XG5cbiAgc2V0VGl0bGUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fdGl0bGVLZXk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBrZXkgfHwgJyc7XG4gICAgY29uc3QgY2hhbmdlZCA9IG5ld1ZhbHVlICE9PSBwcmV2aW91c1ZhbHVlO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX3RpdGxlS2V5ID0gbmV3VmFsdWU7XG5cbiAgICAgIGNvbnN0IHRyYW5zbGF0ZWQgPSB0aGlzLnRyYW5zbGF0ZS5nZXQobmV3VmFsdWUpO1xuICAgICAgdGhpcy50aXRsZS5zZXRUaXRsZSh0cmFuc2xhdGVkKTtcblxuICAgICAgdGhpcy5jaGFuZ2VkLm5leHQoe1xuICAgICAgICBwcmV2aW91c1ZhbHVlOiBwcmV2aW91c1ZhbHVlLFxuICAgICAgICBjdXJyZW50VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uTGFuZ3VhZ2VDaGFuZ2VkKCkge1xuICAgIGlmICh0aGlzLl90aXRsZUtleSkge1xuICAgICAgY29uc3QgdHJhbnNsYXRlZCA9IHRoaXMudHJhbnNsYXRlLmdldCh0aGlzLl90aXRsZUtleSk7XG4gICAgICB0aGlzLnRpdGxlLnNldFRpdGxlKHRyYW5zbGF0ZWQpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSwgVHJhbnNsYXRlUGFyYW1zIH0gZnJvbSAnLi90cmFuc2xhdGUuc2VydmljZSc7XG5cbkBQaXBlKHtcbiAgbmFtZTogJ3RyYW5zbGF0ZScsXG4gIHB1cmU6IGZhbHNlXG59KVxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0ZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0cmFuc2xhdGU6IFRyYW5zbGF0ZVNlcnZpY2UpIHt9XG5cbiAgdHJhbnNmb3JtKGtleTogc3RyaW5nLCBwYXJhbXM/OiBUcmFuc2xhdGVQYXJhbXMpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZS5nZXQoa2V5LCBwYXJhbXMpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSwgTW9kdWxlV2l0aFByb3ZpZGVycyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEh0dHBDbGllbnRNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlLCBUUkFOU0xBVEVfU0VUVElOR1MgfSBmcm9tICcuL3RyYW5zbGF0ZS5zZXJ2aWNlJztcbmltcG9ydCB7IFRyYW5zbGF0ZVBpcGUgfSBmcm9tICcuL3RyYW5zbGF0ZS5waXBlJztcbmltcG9ydCB7IFRpdGxlU2VydmljZSB9IGZyb20gJy4vdGl0bGUuc2VydmljZSc7XG5pbXBvcnQgeyBUcmFuc2xhdGVTZXR0aW5ncyB9IGZyb20gJy4vdHJhbnNsYXRlLnNldHRpbmdzJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgSHR0cENsaWVudE1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW1RyYW5zbGF0ZVBpcGVdLFxuICBleHBvcnRzOiBbVHJhbnNsYXRlUGlwZV1cbn0pXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRlTW9kdWxlIHtcbiAgc3RhdGljIGZvclJvb3Qoc2V0dGluZ3M/OiBUcmFuc2xhdGVTZXR0aW5ncyk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogVHJhbnNsYXRlTW9kdWxlLFxuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHsgcHJvdmlkZTogVFJBTlNMQVRFX1NFVFRJTkdTLCB1c2VWYWx1ZTogc2V0dGluZ3MgfSxcbiAgICAgICAgVHJhbnNsYXRlU2VydmljZSxcbiAgICAgICAgVGl0bGVTZXJ2aWNlXG4gICAgICBdXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBmb3JDaGlsZCgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmdNb2R1bGU6IFRyYW5zbGF0ZU1vZHVsZVxuICAgIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFVQSxNQUFhLGtCQUFrQixHQUFHLElBQUksY0FBYyxDQUNsRCxvQkFBb0IsQ0FDckI7TUFTWSxnQkFBZ0I7Ozs7O0lBc0czQixZQUNVLElBQWdCLEVBR3hCLFFBQTJCO1FBSG5CLFNBQUksR0FBSixJQUFJLENBQVk7UUF0R2hCLFNBQUksR0FBMkIsRUFBRSxDQUFDO1FBQ3BDLGtCQUFhLEdBQUcsSUFBSSxDQUFDO1FBRXJCLHFCQUFnQixHQUFHLGFBQWEsQ0FBQzs7OztRQUt6QyxzQkFBaUIsR0FBRyxJQUFJLFlBQVksRUFHaEMsQ0FBQzs7Ozs7OztRQVFMLGNBQVMsR0FBRyxLQUFLLENBQUM7Ozs7OztRQU9sQixpQkFBWSxHQUFHLEtBQUssQ0FBQzs7Ozs7Ozs7OztRQVdyQixtQkFBYyxHQUFhLEVBQUUsQ0FBQzs7Ozs7OztRQVE5QixtQkFBYyxHQUFhLEVBQUUsQ0FBQztRQThENUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMs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