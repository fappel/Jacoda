/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, EventEmitter, Inject, InjectionToken, Optional } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
/** @type {?} */
export var TRANSLATE_SETTINGS = new InjectionToken('TRANSLATE_SETTINGS');
/**
 * @record
 */
export function TranslateParams() { }
var TranslateService = /** @class */ (function () {
    function TranslateService(http, settings) {
        this.http = http;
        this.data = {};
        this._fallbackLang = 'en';
        this._translationRoot = 'assets/i18n';
        /**
         * Raised each time active language gets changed.
         */
        this.activeLangChanged = new EventEmitter();
        /**
         * Toggles debug mode.
         *
         * When in the debug mode, the service automatically prepends active language id to very translated result.
         * That allows to verify that your components support i18n correctly and do not contain hard-coded text.
         */
        this.debugMode = false;
        /**
         * Disable caching and always download language files.
         *
         * Applies cache busting query parameters to urls, for example: '?v=1522426955882'.
         */
        this.disableCache = false;
        /**
         * List of supported languages.
         *
         * The service will attempt to load resource files only for given set of languages,
         * and will automatically use fallback language for all unspecified values.
         *
         * By default this property is empty and service is going to probe all language files.
         * Active and Fallback languages are always taken into account even if you do not specify them in the list.
         */
        this.supportedLangs = [];
        /**
         * List of extra paths to look for translation files.
         *
         * By default this property is empty.
         * The value of `translationRoot` property is always taken into account.
         */
        this.translatePaths = [];
        this.applySettings(settings);
    }
    Object.defineProperty(TranslateService.prototype, "fallbackLang", {
        /**
         * The fallback language to use when a resource string for the active language is not available.
         */
        get: /**
         * The fallback language to use when a resource string for the active language is not available.
         * @return {?}
         */
        function () {
            return this._fallbackLang;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._fallbackLang = value || 'en';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TranslateService.prototype, "activeLang", {
        /**
         * The language to use for the translations.
         */
        get: /**
         * The language to use for the translations.
         * @return {?}
         */
        function () {
            return this._activeLang;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            /** @type {?} */
            var previousValue = this._activeLang;
            /** @type {?} */
            var newValue = value || this.fallbackLang;
            /** @type {?} */
            var changed = newValue !== previousValue;
            if (changed) {
                this._activeLang = newValue;
                this.use(newValue).then(function () {
                    _this.activeLangChanged.next({
                        previousValue: previousValue,
                        currentValue: newValue
                    });
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TranslateService.prototype.getBrowserLanguage = /**
     * @return {?}
     */
    function () {
        var _a = tslib_1.__read(navigator.language
            .replace('-', '_')
            .toLowerCase()
            .split('_'), 1), lang = _a[0] /*, locale*/;
        return lang;
    };
    Object.defineProperty(TranslateService.prototype, "translationRoot", {
        /**
         * The root path to use when loading default translation files.
         * Defaults to 'assets/i18n'.
         */
        get: /**
         * The root path to use when loading default translation files.
         * Defaults to 'assets/i18n'.
         * @return {?}
         */
        function () {
            return this._translationRoot;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._translationRoot = value || 'assets/i18n';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} settings
     * @return {?}
     */
    TranslateService.prototype.applySettings = /**
     * @param {?} settings
     * @return {?}
     */
    function (settings) {
        var _a = this, debugMode = _a.debugMode, disableCache = _a.disableCache, supportedLangs = _a.supportedLangs, translatePaths = _a.translatePaths, translationRoot = _a.translationRoot, activeLang = _a.activeLang;
        /** @type {?} */
        var defaults = tslib_1.__assign({ debugMode: debugMode,
            disableCache: disableCache,
            supportedLangs: supportedLangs,
            translatePaths: translatePaths,
            translationRoot: translationRoot,
            activeLang: activeLang }, settings);
        this.debugMode = defaults.debugMode;
        this.disableCache = defaults.disableCache;
        this.supportedLangs = defaults.supportedLangs;
        this.translatePaths = defaults.translatePaths;
        this.translationRoot = defaults.translationRoot;
        this._activeLang = defaults.activeLang || this.getBrowserLanguage();
    };
    /**
     * Get translated string
     *
     * @param key Translation key
     * @param [params] Translation parameters
     * @param [lang] Language to use for translation
     * @returns Translated string
     * @memberof TranslateService
     */
    /**
     * Get translated string
     *
     * \@memberof TranslateService
     * @param {?} key Translation key
     * @param {?=} params
     * @param {?=} lang
     * @return {?} Translated string
     */
    TranslateService.prototype.get = /**
     * Get translated string
     *
     * \@memberof TranslateService
     * @param {?} key Translation key
     * @param {?=} params
     * @param {?=} lang
     * @return {?} Translated string
     */
    function (key, params, lang) {
        if (key) {
            /** @type {?} */
            var value = this.getValue(lang || this.activeLang, key);
            if (value === key) {
                value = this.getValue(this.fallbackLang, key);
            }
            return this.format(value, params);
        }
        else {
            return null;
        }
    };
    /**
     * @return {?}
     */
    TranslateService.prototype.load = /**
     * @return {?}
     */
    function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.use(this.fallbackLang)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.use(this.activeLang)];
                }
            });
        });
    };
    /**
     * Load the translation file or use provided data for the given language.
     *
     * @param lang Language name
     * @param [data] Translation data to use
     * @returns Final translation data merged with existing translations
     * @memberof TranslateService
     */
    /**
     * Load the translation file or use provided data for the given language.
     *
     * \@memberof TranslateService
     * @param {?} lang Language name
     * @param {?=} data
     * @return {?} Final translation data merged with existing translations
     */
    TranslateService.prototype.use = /**
     * Load the translation file or use provided data for the given language.
     *
     * \@memberof TranslateService
     * @param {?} lang Language name
     * @param {?=} data
     * @return {?} Final translation data merged with existing translations
     */
    function (lang, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1, _a, translation, fileName, filePaths, filePaths_1, filePaths_1_1, path, filePath, e_1_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (lang && data) {
                            return [2 /*return*/, this.setTranslation(lang, data)];
                        }
                        translation = this.data[lang];
                        if (this.isNotSupported(lang)) {
                            translation = this.data[this.fallbackLang];
                        }
                        if (translation && Object.keys(translation).length > 0) {
                            return [2 /*return*/, translation];
                        }
                        fileName = (lang || this.fallbackLang) + ".json";
                        filePaths = tslib_1.__spread([this.translationRoot], (this.translatePaths || []));
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        filePaths_1 = tslib_1.__values(filePaths), filePaths_1_1 = filePaths_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!filePaths_1_1.done) return [3 /*break*/, 5];
                        path = filePaths_1_1.value;
                        filePath = path + "/" + fileName;
                        return [4 /*yield*/, this.loadTranslation(lang, filePath)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        filePaths_1_1 = filePaths_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (filePaths_1_1 && !filePaths_1_1.done && (_a = filePaths_1.return)) _a.call(filePaths_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/, this.data[lang] || {}];
                }
            });
        });
    };
    /**
     * @param {?} lang
     * @param {?} path
     * @return {?}
     */
    TranslateService.prototype.loadTranslation = /**
     * @param {?} lang
     * @param {?} path
     * @return {?}
     */
    function (lang, path) {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this.disableCache) {
                path += "?v=" + Date.now();
            }
            _this.http.get(path).subscribe(function (json) {
                resolve(_this.setTranslation(lang, json));
            }, function () {
                resolve(_this.data[lang] || {});
            });
        });
    };
    /**
     * @param {?} lang
     * @return {?}
     */
    TranslateService.prototype.isNotSupported = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        return (lang !== this.fallbackLang &&
            lang !== this.activeLang &&
            (this.supportedLangs &&
                this.supportedLangs.length > 0 &&
                !this.supportedLangs.includes(lang)));
    };
    /**
     * @param {?} lang
     * @param {?} key
     * @return {?}
     */
    TranslateService.prototype.getValue = /**
     * @param {?} lang
     * @param {?} key
     * @return {?}
     */
    function (lang, key) {
        /** @type {?} */
        var data = this.data[lang];
        if (this.isNotSupported(lang)) {
            data = this.data[this.fallbackLang];
        }
        if (!data) {
            return key;
        }
        /** @type {?} */
        var keys = key.split('.');
        /** @type {?} */
        var propKey = '';
        do {
            propKey += keys.shift();
            /** @type {?} */
            var value = data[propKey];
            if (value !== undefined && (typeof value === 'object' || !keys.length)) {
                data = value;
                propKey = '';
            }
            else if (!keys.length) {
                data = key;
            }
            else {
                propKey += '.';
            }
        } while (keys.length);
        return data;
    };
    /**
     * @param {?} lang
     * @param {?} data
     * @return {?}
     */
    TranslateService.prototype.setTranslation = /**
     * @param {?} lang
     * @param {?} data
     * @return {?}
     */
    function (lang, data) {
        /** @type {?} */
        var finalResult = this.data[lang] || {};
        finalResult = this.merge(finalResult, data || {});
        this.data[lang] = finalResult;
        return finalResult;
    };
    /**
     * @param {...?} translations
     * @return {?}
     */
    TranslateService.prototype.merge = /**
     * @param {...?} translations
     * @return {?}
     */
    function () {
        var _this = this;
        var translations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            translations[_i] = arguments[_i];
        }
        /** @type {?} */
        var result = {};
        translations.forEach(function (translation) {
            Object.keys(translation).forEach(function (key) {
                if (key in result && Array.isArray(result[key])) {
                    result[key] = result[key].concat(translation[key]);
                }
                else if (key in result && typeof result[key] === 'object') {
                    result[key] = _this.merge(result[key], translation[key]);
                }
                else {
                    result[key] = translation[key];
                }
            });
        });
        return result;
    };
    /**
     * @param {?} str
     * @param {?} params
     * @return {?}
     */
    TranslateService.prototype.format = /**
     * @param {?} str
     * @param {?} params
     * @return {?}
     */
    function (str, params) {
        /** @type {?} */
        var result = str;
        if (params) {
            Object.keys(params).forEach(function (key) {
                /** @type {?} */
                var value = params[key];
                /** @type {?} */
                var template = new RegExp('{' + key + '}', 'gm');
                result = result.replace(template, value);
            });
        }
        if (this.debugMode) {
            result = "[" + this.activeLang + "] " + result;
        }
        return result;
    };
    TranslateService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    TranslateService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLATE_SETTINGS,] }] }
    ]; };
    /** @nocollapse */ TranslateService.ngInjectableDef = i0.defineInjectable({ factory: function TranslateService_Factory() { return new TranslateService(i0.inject(i1.HttpClient), i0.inject(TRANSLATE_SETTINGS, 8)); }, token: TranslateService, providedIn: "root" });
    return TranslateService;
}());
export { TranslateService };
if (false) {
    /** @type {?} */
    TranslateService.prototype.data;
    /** @type {?} */
    TranslateService.prototype._fallbackLang;
    /** @type {?} */
    TranslateService.prototype._activeLang;
    /** @type {?} */
    TranslateService.prototype._translationRoot;
    /**
     * Raised each time active language gets changed.
     * @type {?}
     */
    TranslateService.prototype.activeLangChanged;
    /**
     * Toggles debug mode.
     *
     * When in the debug mode, the service automatically prepends active language id to very translated result.
     * That allows to verify that your components support i18n correctly and do not contain hard-coded text.
     * @type {?}
     */
    TranslateService.prototype.debugMode;
    /**
     * Disable caching and always download language files.
     *
     * Applies cache busting query parameters to urls, for example: '?v=1522426955882'.
     * @type {?}
     */
    TranslateService.prototype.disableCache;
    /**
     * List of supported languages.
     *
     * The service will attempt to load resource files only for given set of languages,
     * and will automatically use fallback language for all unspecified values.
     *
     * By default this property is empty and service is going to probe all language files.
     * Active and Fallback languages are always taken into account even if you do not specify them in the list.
     * @type {?}
     */
    TranslateService.prototype.supportedLangs;
    /**
     * List of extra paths to look for translation files.
     *
     * By default this property is empty.
     * The value of `translationRoot` property is always taken into account.
     * @type {?}
     */
    TranslateService.prototype.translatePaths;
    /** @type {?} */
    TranslateService.prototype.http;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmdzdGFjay90cmFuc2xhdGUvIiwic291cmNlcyI6WyJsaWIvdHJhbnNsYXRlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQ0wsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sY0FBYyxFQUNkLFFBQVEsRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7Ozs7QUFHbEQsTUFBTSxLQUFPLGtCQUFrQixHQUFHLElBQUksY0FBYyxDQUNsRCxvQkFBb0IsQ0FDckI7Ozs7QUFFRCxxQ0FFQztBQUVEO0lBeUdFLDBCQUNVLElBQWdCLEVBR3hCLFFBQTJCO1FBSG5CLFNBQUksR0FBSixJQUFJLENBQVk7UUF0R2hCLFNBQUksR0FBMkIsRUFBRSxDQUFDO1FBQ3BDLGtCQUFhLEdBQUcsSUFBSSxDQUFDO1FBRXJCLHFCQUFnQixHQUFHLGFBQWEsQ0FBQzs7OztRQUt6QyxzQkFBaUIsR0FBRyxJQUFJLFlBQVksRUFHaEMsQ0FBQzs7Ozs7OztRQVFMLGNBQVMsR0FBRyxLQUFLLENBQUM7Ozs7OztRQU9sQixpQkFBWSxHQUFHLEtBQUssQ0FBQzs7Ozs7Ozs7OztRQVdyQixtQkFBYyxHQUFhLEVBQUUsQ0FBQzs7Ozs7OztRQVE5QixtQkFBYyxHQUFhLEVBQUUsQ0FBQztRQThENUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBMURELHNCQUFJLDBDQUFZO1FBSGhCOztXQUVHOzs7OztRQUNIO1lBQ0UsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQzVCLENBQUM7Ozs7O1FBRUQsVUFBaUIsS0FBYTtZQUM1QixJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssSUFBSSxJQUFJLENBQUM7UUFDckMsQ0FBQzs7O09BSkE7SUFTRCxzQkFBSSx3Q0FBVTtR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LFNBQVMsRUFBRTtZQUNsQixNQUFNLEdBQUcsTUFBSSxJQUFJLENBQUMsVUFBVSxVQUFLLE1BQVEsQ0FBQztTQUMzQztRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O2dCQTNTRixVQUFVLFNBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzs7O2dCQWJRLFVBQVU7Z0RBc0hkLFFBQVEsWUFDUixNQUFNLFNBQUMsa0JBQWtCOzs7MkJBOUg5QjtDQThUQyxBQTVTRCxJQTRTQztTQXpTWSxnQkFBZ0I7OztJQUMzQixnQ0FBNEM7O0lBQzVDLHlDQUE2Qjs7SUFDN0IsdUNBQW9COztJQUNwQiw0Q0FBeUM7Ozs7O0lBS3pDLDZDQUdLOzs7Ozs7OztJQVFMLHFDQUFrQjs7Ozs7OztJQU9sQix3Q0FBcUI7Ozs7Ozs7Ozs7O0lBV3JCLDBDQUE4Qjs7Ozs7Ozs7SUFROUIsMENBQThCOztJQXlENUIsZ0NBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSW5qZWN0YWJsZSxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIEluamVjdGlvblRva2VuLFxuICBPcHRpb25hbFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBUcmFuc2xhdGVTZXR0aW5ncyB9IGZyb20gJy4vdHJhbnNsYXRlLnNldHRpbmdzJztcblxuZXhwb3J0IGNvbnN0IFRSQU5TTEFURV9TRVRUSU5HUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxUcmFuc2xhdGVTZXR0aW5ncz4oXG4gICdUUkFOU0xBVEVfU0VUVElOR1MnXG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0ZVBhcmFtcyB7XG4gIFtrZXk6IHN0cmluZ106IHN0cmluZztcbn1cblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRlU2VydmljZSB7XG4gIHByb3RlY3RlZCBkYXRhOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge307XG4gIHByaXZhdGUgX2ZhbGxiYWNrTGFuZyA9ICdlbic7XG4gIHByaXZhdGUgX2FjdGl2ZUxhbmc7XG4gIHByaXZhdGUgX3RyYW5zbGF0aW9uUm9vdCA9ICdhc3NldHMvaTE4bic7XG5cbiAgLyoqXG4gICAqIFJhaXNlZCBlYWNoIHRpbWUgYWN0aXZlIGxhbmd1YWdlIGdldHMgY2hhbmdlZC5cbiAgICovXG4gIGFjdGl2ZUxhbmdDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjx7XG4gICAgcHJldmlvdXNWYWx1ZTogc3RyaW5nO1xuICAgIGN1cnJlbnRWYWx1ZTogc3RyaW5nO1xuICB9PigpO1xuXG4gIC8qKlxuICAgKiBUb2dnbGVzIGRlYnVnIG1vZGUuXG4gICAqXG4gICAqIFdoZW4gaW4gdGhlIGRlYnVnIG1vZGUsIHRoZSBzZXJ2aWNlIGF1dG9tYXRpY2FsbHkgcHJlcGVuZHMgYWN0aXZlIGxhbmd1YWdlIGlkIHRvIHZlcnkgdHJhbnNsYXRlZCByZXN1bHQuXG4gICAqIFRoYXQgYWxsb3dzIHRvIHZlcmlmeSB0aGF0IHlvdXIgY29tcG9uZW50cyBzdXBwb3J0IGkxOG4gY29ycmVjdGx5IGFuZCBkbyBub3QgY29udGFpbiBoYXJkLWNvZGVkIHRleHQuXG4gICAqL1xuICBkZWJ1Z01vZGUgPSBmYWxzZTtcblxuICAvKipcbiAgICogRGlzYWJsZSBjYWNoaW5nIGFuZCBhbHdheXMgZG93bmxvYWQgbGFuZ3VhZ2UgZmlsZXMuXG4gICAqXG4gICAqIEFwcGxpZXMgY2FjaGUgYnVzdGluZyBxdWVyeSBwYXJhbWV0ZXJzIHRvIHVybHMsIGZvciBleGFtcGxlOiAnP3Y9MTUyMjQyNjk1NTg4MicuXG4gICAqL1xuICBkaXNhYmxlQ2FjaGUgPSBmYWxzZTtcblxuICAvKipcbiAgICogTGlzdCBvZiBzdXBwb3J0ZWQgbGFuZ3VhZ2VzLlxuICAgKlxuICAgKiBUaGUgc2VydmljZSB3aWxsIGF0dGVtcHQgdG8gbG9hZCByZXNvdXJjZSBmaWxlcyBvbmx5IGZvciBnaXZlbiBzZXQgb2YgbGFuZ3VhZ2VzLFxuICAgKiBhbmQgd2lsbCBhdXRvbWF0aWNhbGx5IHVzZSBmYWxsYmFjayBsYW5ndWFnZSBmb3IgYWxsIHVuc3BlY2lmaWVkIHZhbHVlcy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIHByb3BlcnR5IGlzIGVtcHR5IGFuZCBzZXJ2aWNlIGlzIGdvaW5nIHRvIHByb2JlIGFsbCBsYW5ndWFnZSBmaWxlcy5cbiAgICogQWN0aXZlIGFuZCBGYWxsYmFjayBsYW5ndWFnZXMgYXJlIGFsd2F5cyB0YWtlbiBpbnRvIGFjY291bnQgZXZlbiBpZiB5b3UgZG8gbm90IHNwZWNpZnkgdGhlbSBpbiB0aGUgbGlzdC5cbiAgICovXG4gIHN1cHBvcnRlZExhbmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGV4dHJhIHBhdGhzIHRvIGxvb2sgZm9yIHRyYW5zbGF0aW9uIGZpbGVzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoaXMgcHJvcGVydHkgaXMgZW1wdHkuXG4gICAqIFRoZSB2YWx1ZSBvZiBgdHJhbnNsYXRpb25Sb290YCBwcm9wZXJ0eSBpcyBhbHdheXMgdGFrZW4gaW50byBhY2NvdW50LlxuICAgKi9cbiAgdHJhbnNsYXRlUGF0aHM6IHN0cmluZ1tdID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBmYWxsYmFjayBsYW5ndWFnZSB0byB1c2Ugd2hlbiBhIHJlc291cmNlIHN0cmluZyBmb3IgdGhlIGFjdGl2ZSBsYW5ndWFnZSBpcyBub3QgYXZhaWxhYmxlLlxuICAgKi9cbiAgZ2V0IGZhbGxiYWNrTGFuZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9mYWxsYmFja0xhbmc7XG4gIH1cblxuICBzZXQgZmFsbGJhY2tMYW5nKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9mYWxsYmFja0xhbmcgPSB2YWx1ZSB8fCAnZW4nO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIHRoZSB0cmFuc2xhdGlvbnMuXG4gICAqL1xuICBnZXQgYWN0aXZlTGFuZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVMYW5nO1xuICB9XG5cbiAgc2V0IGFjdGl2ZUxhbmcodmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLl9hY3RpdmVMYW5nO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgfHwgdGhpcy5mYWxsYmFja0xhbmc7XG4gICAgY29uc3QgY2hhbmdlZCA9IG5ld1ZhbHVlICE9PSBwcmV2aW91c1ZhbHVlO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZUxhbmcgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMudXNlKG5ld1ZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5hY3RpdmVMYW5nQ2hhbmdlZC5uZXh0KHtcbiAgICAgICAgICBwcmV2aW91c1ZhbHVlOiBwcmV2aW91c1ZhbHVlLFxuICAgICAgICAgIGN1cnJlbnRWYWx1ZTogbmV3VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXRCcm93c2VyTGFuZ3VhZ2UoKTogc3RyaW5nIHtcbiAgICBjb25zdCBbbGFuZyAvKiwgbG9jYWxlKi9dID0gbmF2aWdhdG9yLmxhbmd1YWdlXG4gICAgICAucmVwbGFjZSgnLScsICdfJylcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAuc3BsaXQoJ18nKTtcbiAgICByZXR1cm4gbGFuZztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcm9vdCBwYXRoIHRvIHVzZSB3aGVuIGxvYWRpbmcgZGVmYXVsdCB0cmFuc2xhdGlvbiBmaWxlcy5cbiAgICogRGVmYXVsdHMgdG8gJ2Fzc2V0cy9pMThuJy5cbiAgICovXG4gIGdldCB0cmFuc2xhdGlvblJvb3QoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNsYXRpb25Sb290O1xuICB9XG5cbiAgc2V0IHRyYW5zbGF0aW9uUm9vdCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fdHJhbnNsYXRpb25Sb290ID0gdmFsdWUgfHwgJ2Fzc2V0cy9pMThuJztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaHR0cDogSHR0cENsaWVudCxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoVFJBTlNMQVRFX1NFVFRJTkdTKVxuICAgIHNldHRpbmdzOiBUcmFuc2xhdGVTZXR0aW5nc1xuICApIHtcbiAgICB0aGlzLmFwcGx5U2V0dGluZ3Moc2V0dGluZ3MpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFwcGx5U2V0dGluZ3Moc2V0dGluZ3M6IFRyYW5zbGF0ZVNldHRpbmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVidWdNb2RlLFxuICAgICAgZGlzYWJsZUNhY2hlLFxuICAgICAgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICB0cmFuc2xhdGVQYXRocyxcbiAgICAgIHRyYW5zbGF0aW9uUm9vdCxcbiAgICAgIGFjdGl2ZUxhbmdcbiAgICB9ID0gdGhpcztcblxuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgZGVidWdNb2RlLFxuICAgICAgZGlzYWJsZUNhY2hlLFxuICAgICAgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICB0cmFuc2xhdGVQYXRocyxcbiAgICAgIHRyYW5zbGF0aW9uUm9vdCxcbiAgICAgIGFjdGl2ZUxhbmcsXG4gICAgICAuLi5zZXR0aW5nc1xuICAgIH07XG5cbiAgICB0aGlzLmRlYnVnTW9kZSA9IGRlZmF1bHRzLmRlYnVnTW9kZTtcbiAgICB0aGlzLmRpc2FibGVDYWNoZSA9IGRlZmF1bHRzLmRpc2FibGVDYWNoZTtcbiAgICB0aGlzLnN1cHBvcnRlZExhbmdzID0gZGVmYXVsdHMuc3VwcG9ydGVkTGFuZ3M7XG4gICAgdGhpcy50cmFuc2xhdGVQYXRocyA9IGRlZmF1bHRzLnRyYW5zbGF0ZVBhdGhzO1xuICAgIHRoaXMudHJhbnNsYXRpb25Sb290ID0gZGVmYXVsdHMudHJhbnNsYXRpb25Sb290O1xuICAgIHRoaXMuX2FjdGl2ZUxhbmcgPSBkZWZhdWx0cy5hY3RpdmVMYW5nIHx8IHRoaXMuZ2V0QnJvd3Nlckxhbmd1YWdlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRyYW5zbGF0ZWQgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVHJhbnNsYXRpb24ga2V5XG4gICAqIEBwYXJhbSBbcGFyYW1zXSBUcmFuc2xhdGlvbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBbbGFuZ10gTGFuZ3VhZ2UgdG8gdXNlIGZvciB0cmFuc2xhdGlvblxuICAgKiBAcmV0dXJucyBUcmFuc2xhdGVkIHN0cmluZ1xuICAgKiBAbWVtYmVyb2YgVHJhbnNsYXRlU2VydmljZVxuICAgKi9cbiAgZ2V0KGtleTogc3RyaW5nLCBwYXJhbXM/OiBUcmFuc2xhdGVQYXJhbXMsIGxhbmc/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChrZXkpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUobGFuZyB8fCB0aGlzLmFjdGl2ZUxhbmcsIGtleSk7XG4gICAgICBpZiAodmFsdWUgPT09IGtleSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUodGhpcy5mYWxsYmFja0xhbmcsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXQodmFsdWUsIHBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGxvYWQoKTogUHJvbWlzZTxhbnk+IHtcbiAgICBhd2FpdCB0aGlzLnVzZSh0aGlzLmZhbGxiYWNrTGFuZyk7XG4gICAgcmV0dXJuIHRoaXMudXNlKHRoaXMuYWN0aXZlTGFuZyk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCB0aGUgdHJhbnNsYXRpb24gZmlsZSBvciB1c2UgcHJvdmlkZWQgZGF0YSBmb3IgdGhlIGdpdmVuIGxhbmd1YWdlLlxuICAgKlxuICAgKiBAcGFyYW0gbGFuZyBMYW5ndWFnZSBuYW1lXG4gICAqIEBwYXJhbSBbZGF0YV0gVHJhbnNsYXRpb24gZGF0YSB0byB1c2VcbiAgICogQHJldHVybnMgRmluYWwgdHJhbnNsYXRpb24gZGF0YSBtZXJnZWQgd2l0aCBleGlzdGluZyB0cmFuc2xhdGlvbnNcbiAgICogQG1lbWJlcm9mIFRyYW5zbGF0ZVNlcnZpY2VcbiAgICovXG4gIGFzeW5jIHVzZShsYW5nOiBzdHJpbmcsIGRhdGE/OiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmIChsYW5nICYmIGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFRyYW5zbGF0aW9uKGxhbmcsIGRhdGEpO1xuICAgIH1cblxuICAgIGxldCB0cmFuc2xhdGlvbiA9IHRoaXMuZGF0YVtsYW5nXTtcbiAgICBpZiAodGhpcy5pc05vdFN1cHBvcnRlZChsYW5nKSkge1xuICAgICAgdHJhbnNsYXRpb24gPSB0aGlzLmRhdGFbdGhpcy5mYWxsYmFja0xhbmddO1xuICAgIH1cblxuICAgIGlmICh0cmFuc2xhdGlvbiAmJiBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbikubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7bGFuZyB8fCB0aGlzLmZhbGxiYWNrTGFuZ30uanNvbmA7XG4gICAgY29uc3QgZmlsZVBhdGhzID0gW3RoaXMudHJhbnNsYXRpb25Sb290LCAuLi4odGhpcy50cmFuc2xhdGVQYXRocyB8fCBbXSldO1xuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIGZpbGVQYXRocykge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBgJHtwYXRofS8ke2ZpbGVOYW1lfWA7XG4gICAgICBhd2FpdCB0aGlzLmxvYWRUcmFuc2xhdGlvbihsYW5nLCBmaWxlUGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YVtsYW5nXSB8fCB7fTtcbiAgfVxuXG4gIHByb3RlY3RlZCBsb2FkVHJhbnNsYXRpb24obGFuZzogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxhbnk+KHJlc29sdmUgPT4ge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZUNhY2hlKSB7XG4gICAgICAgIHBhdGggKz0gYD92PSR7RGF0ZS5ub3coKX1gO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmh0dHAuZ2V0PHt9PihwYXRoKS5zdWJzY3JpYmUoXG4gICAgICAgIGpzb24gPT4ge1xuICAgICAgICAgIHJlc29sdmUodGhpcy5zZXRUcmFuc2xhdGlvbihsYW5nLCBqc29uKSk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMuZGF0YVtsYW5nXSB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgaXNOb3RTdXBwb3J0ZWQobGFuZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICBsYW5nICE9PSB0aGlzLmZhbGxiYWNrTGFuZyAmJlxuICAgICAgbGFuZyAhPT0gdGhpcy5hY3RpdmVMYW5nICYmXG4gICAgICAodGhpcy5zdXBwb3J0ZWRMYW5ncyAmJlxuICAgICAgICB0aGlzLnN1cHBvcnRlZExhbmdzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgIXRoaXMuc3VwcG9ydGVkTGFuZ3MuaW5jbHVkZXMobGFuZykpXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRWYWx1ZShsYW5nOiBzdHJpbmcsIGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YVtsYW5nXTtcbiAgICBpZiAodGhpcy5pc05vdFN1cHBvcnRlZChsYW5nKSkge1xuICAgICAgZGF0YSA9IHRoaXMuZGF0YVt0aGlzLmZhbGxiYWNrTGFuZ107XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICBsZXQgcHJvcEtleSA9ICcnO1xuXG4gICAgZG8ge1xuICAgICAgcHJvcEtleSArPSBrZXlzLnNoaWZ0KCk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbcHJvcEtleV07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCAha2V5cy5sZW5ndGgpKSB7XG4gICAgICAgIGRhdGEgPSB2YWx1ZTtcbiAgICAgICAgcHJvcEtleSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IGtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BLZXkgKz0gJy4nO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGtleXMubGVuZ3RoKTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNldFRyYW5zbGF0aW9uKGxhbmc6IHN0cmluZywgZGF0YTogYW55KTogYW55IHtcbiAgICBsZXQgZmluYWxSZXN1bHQgPSB0aGlzLmRhdGFbbGFuZ10gfHwge307XG4gICAgZmluYWxSZXN1bHQgPSB0aGlzLm1lcmdlKGZpbmFsUmVzdWx0LCBkYXRhIHx8IHt9KTtcbiAgICB0aGlzLmRhdGFbbGFuZ10gPSBmaW5hbFJlc3VsdDtcbiAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWVyZ2UoLi4udHJhbnNsYXRpb25zKTogYW55IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgIHRyYW5zbGF0aW9ucy5mb3JFYWNoKHRyYW5zbGF0aW9uID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHRyYW5zbGF0aW9uKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChrZXkgaW4gcmVzdWx0ICYmIEFycmF5LmlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSByZXN1bHRba2V5XS5jb25jYXQodHJhbnNsYXRpb25ba2V5XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLm1lcmdlKHJlc3VsdFtrZXldLCB0cmFuc2xhdGlvbltrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHRyYW5zbGF0aW9uW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByb3RlY3RlZCBmb3JtYXQoc3RyOiBzdHJpbmcsIHBhcmFtczogVHJhbnNsYXRlUGFyYW1zKTogc3RyaW5nIHtcbiAgICBsZXQgcmVzdWx0ID0gc3RyO1xuXG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gbmV3IFJlZ0V4cCgneycgKyBrZXkgKyAnfScsICdnbScpO1xuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKHRlbXBsYXRlLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHtcbiAgICAgIHJlc3VsdCA9IGBbJHt0aGlzLmFjdGl2ZUxhbmd9XSAke3Jlc3VsdH1gO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbiJdfQ==